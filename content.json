{"meta":{"title":"Geiz-Revive","subtitle":null,"description":null,"author":"Geiz-Revive","url":"http://Geiz-Revive.github.io","root":"/"},"pages":[{"title":"404","date":"2019-06-04T04:39:02.000Z","updated":"2019-06-04T04:39:02.294Z","comments":true,"path":"404/index.html","permalink":"http://Geiz-Revive.github.io/404/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-06-04T04:56:03.000Z","updated":"2019-06-04T10:37:10.205Z","comments":true,"path":"about/index.html","permalink":"http://Geiz-Revive.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-06-04T04:54:34.000Z","updated":"2019-06-04T04:54:34.464Z","comments":true,"path":"categories/index.html","permalink":"http://Geiz-Revive.github.io/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2019-06-04T04:38:50.000Z","updated":"2019-06-04T04:38:50.824Z","comments":true,"path":"search/index.html","permalink":"http://Geiz-Revive.github.io/search/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-06-03T13:39:13.000Z","updated":"2019-07-18T23:37:03.038Z","comments":true,"path":"tags/index.html","permalink":"http://Geiz-Revive.github.io/tags/index.html","excerpt":"","text":"莫队 $LCT$ 线段树 数学 主席树 线段树合并"},{"title":"归档","date":"2019-06-03T13:34:48.000Z","updated":"2019-06-03T13:41:35.722Z","comments":true,"path":"archives/index.html","permalink":"http://Geiz-Revive.github.io/archives/index.html","excerpt":"","text":""}],"posts":[{"title":"洛谷-P5350-序列","slug":"洛谷-P5350-序列","date":"2019-09-24T08:03:36.000Z","updated":"2019-09-24T08:06:25.320Z","comments":true,"path":"2019/09/24/洛谷-P5350-序列/","link":"","permalink":"http://Geiz-Revive.github.io/2019/09/24/洛谷-P5350-序列/","excerpt":"","text":"$\\large \\color{blue} Describe$ 这题只有在数据随机的情况下4操作的复杂度才是正确的，因为数据随机，因此我们可以考虑平衡树维护相同值域连续段，然后重点就是拆区间，我们考虑把在找节点时把一个连续段拆成3段x、y、z，把z作为y的后继，y作为x的后继，再返回y即可，其他思路都非常简单，主要考察代码能力。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#define poi(x) (rs(fa(x)) == (x))#define reverse(x) (swap(ls(x), rs(x)), t[x].filp ^= 1)const int p = 1e9 + 7;stack&lt;int&gt; st;int rt, cnt, a[300005], len[300005];struct node &#123; int fa, child[2], tot, sum, w, size, len; bool filp, tag;&#125; t[3000005];inl void upd(int x) &#123; t[x].tot = ((t[ls(x)].tot + t[rs(x)].tot) % p + (1ll * t[x].w * t[x].len)) % p; t[x].size = t[ls(x)].size + t[rs(x)].size + t[x].len;&#125;inl int newn(int w, int len) &#123; re x; if (!st.empty()) x = st.top(), st.pop(); else x = ++cnt; t[x].size = t[x].tot = fa(x) = ls(x) = rs(x) = t[x].filp = t[x].sum = 0; t[x].w = w, t[x].len = len, upd(x); return x;&#125;inl void rotate(int x) &#123; re f = fa(x), gf = fa(f), fs = poi(x), gfs = poi(f), s = son(x, fs ^ 1); if (gf) son(gf, gfs) = x; son(f, fs) = s, son(x, fs ^ 1) = f; if (s) fa(s) = f; fa(f) = x, fa(x) = gf, upd(f);&#125;inl void sum(int x, int w) &#123; t[x].tot = (t[x].tot + 1ll * w * t[x].size) % p, t[x].w = (t[x].w + w) % p, t[x].sum = (t[x].sum + w) % p; &#125;inl void pushdown(int x) &#123; if (t[x].sum) &#123; if (ls(x)) sum(ls(x), t[x].sum); if (rs(x)) sum(rs(x), t[x].sum); t[x].sum = 0; &#125; if (t[x].filp) &#123; if (ls(x)) reverse(ls(x)); if (rs(x)) reverse(rs(x)); t[x].filp = 0; &#125;&#125;inl void push(int x) &#123; if (fa(x)) push(fa(x)); pushdown(x);&#125;inl void splay(int x, int to = 0) &#123; push(x); while (fa(x) != to) &#123; if (fa(fa(x)) != to) poi(x) == poi(fa(x)) ? rotate(fa(x)) : rotate(x); rotate(x); &#125; if (!to) rt = x; upd(x);&#125;inl int split(int x, int k) &#123; re y = newn(t[x].w, t[x].len - k); t[x].len = k; if (!rs(x))fa(rs(x) = y) = x; else &#123; pushdown(x); re o = rs(x); pushdown(o); while (ls(o))pushdown(o = ls(o)); fa(ls(o) = y) = o; while (o != x) upd(o), o = fa(o); &#125; splay(y); return y;&#125;inl void find(int k) &#123; re x = rt; while (x) &#123; pushdown(x); if (t[ls(x)].size &gt;= k) x = ls(x); else &#123; k -= t[ls(x)].size; if (t[x].len &gt;= k) &#123; if (k != t[x].len)split(x, k); if (k != 1)x = split(x, k - 1); return splay(x); &#125; else k -= t[x].len, x = rs(x); &#125; &#125;&#125;inl int nxt(int k, bool f) &#123; find(k); re x = rt; x = son(x, f); while (son(x, f ^ 1))pushdown(x), x = son(x, f ^ 1); return x;&#125;inl void build(int &amp;k, int l, int r) &#123; if (l &gt; r) return; re mid = l + r &gt;&gt; 1; k = newn(a[mid], len[mid]); if (a[mid] == inf)t[k].tag = 1, t[k].w = 0, upd(k); build(ls(k), l, mid - 1), build(rs(k), mid + 1, r); if (ls(k))fa(ls(k)) = k; if (rs(k)) fa(rs(k)) = k; upd(k);&#125;int num;inl void travel(int x) &#123; pushdown(x); if (ls(x)) travel(ls(x)); a[++num] = t[x].w, len[num] = t[x].len; if (rs(x)) travel(rs(x));&#125;inl void erase(int x) &#123; if (ls(x)) erase(ls(x)); st.push(x); if (rs(x)) erase(rs(x));&#125;inl void change(int x, int w) &#123; if (w == 1) &#123; t[x].w = w, upd(x); return; &#125; erase(x); re k = fa(x); ls(k) = fa(x) = 0; fa(ls(k) = newn(w, t[x].size)) = k; splay(ls(k));&#125;inl void print(int x) &#123; pushdown(x); if (ls(x))print(ls(x)); if (!t[x].tag)for (re i = 1; i &lt;= t[x].len; i++)writesp(t[x].w); if (rs(x))print(rs(x));&#125;inl int cut(int a, int b) &#123; re l, r; find(a), l = rt, find(b + 2), r = rt; splay(l), splay(r, l); return ls(r);&#125;signed main() &#123; re n = read&lt;int&gt;(), m = read&lt;int&gt;(), l, r, op, l1, r1, w, tmp1, tmp2, f; a[++num] = inf, len[num] = 1; for (re i = 1; i &lt;= n; i++) a[++num] = read&lt;int&gt;() % p, len[num] = 1; a[++num] = inf, len[num] = 1; build(rt, 1, num); while (m--) &#123; op = read&lt;int&gt;(), l = read&lt;int&gt;(), r = read&lt;int&gt;(); switch (op) &#123; case 1: &#123; writeln(t[cut(l, r)].tot); break; &#125; case 2: &#123; w = read&lt;int&gt;() % p; change(cut(l, r), w); break; &#125; case 3: &#123; w = read&lt;int&gt;() % p; sum(cut(l, r), w); break; &#125; case 4: &#123; l1 = read&lt;int&gt;(), r1 = read&lt;int&gt;(); num = 0, travel(cut(l, r)); build(tmp1, 1, num); erase(tmp2 = cut(l1, r1)); ls(fa(tmp2)) = 0, f = fa(tmp2), fa(tmp2) = 0; fa(ls(f) = tmp1) = f; splay(ls(f)); break; &#125; case 5: &#123; l1 = read&lt;int&gt;(), r1 = read&lt;int&gt;(); num = 0, travel(cut(l, r)); build(tmp1, 1, num); tmp2 = cut(l1, r1); ls(fa(tmp2)) = 0, f = fa(tmp2), fa(tmp2) = 0; fa(ls(f) = tmp1) = f; splay(ls(f)); f = cut(l, r); ls(fa(f)) = tmp2, fa(tmp2) = fa(f), fa(f) = 0; erase(f); break; &#125; case 6: &#123; f = cut(l, r); reverse(f); break; &#125; &#125; &#125; print(rt);&#125;","categories":[],"tags":[{"name":"Splay","slug":"Splay","permalink":"http://Geiz-Revive.github.io/tags/Splay/"}]},{"title":"多项式全家桶","slug":"多项式全家桶","date":"2019-09-08T09:11:17.000Z","updated":"2019-09-08T11:39:11.136Z","comments":true,"path":"2019/09/08/多项式全家桶/","link":"","permalink":"http://Geiz-Revive.github.io/2019/09/08/多项式全家桶/","excerpt":"","text":"学了这么久多项式，是时候来个总结了。 先从最初的$FFT$开始 $FFT$快速傅里叶变换 ($\\text{fast Fourier transform}$), 即利用计算机计算离散傅里叶变换($DFT$)的高效、快速计算方法的统称，简称FFT。 （上面是从百科抄的 FFT能在$\\Theta(nlog_n)$的时间内求出一个多项式的点值表达的算法 1注：假设我们有一个n-1次的多项式，它的点值表达即用n个不同的x代入多项式所得到的n个y，这n对(x,y)唯一确定了该多项式。 然后FFT就是用一些特别的x的取值来快速的得出这n个y。 前置芝士：复数 一个复数可以写成$a+bi$的形式 其中$i$叫虚数单位，$i=\\sqrt{-1}$，可以把一个复数想象成一个向量$(a,bi)$ 复数相乘的规则：模长相乘，辐角相加。 但是$FFT$只用到了后半句（ 如果写成向量那么复数的运算就可以这样写： 12345假设我们现在有两个复数 x(a,bi) 和 y(c,di) x + y = (a + c,(b + d)i) x - y = (a - c,(b - d)i) x * y = (a * c - b * d,(a * c + b * d)i)其中乘法就是写成(a + bi) * (c + di)的形式再展开 $STL$提供了复数$complex$的模板，可以直接用，但是常数不小，建议手写。 复数类的模板： 1234567struct complex &#123; double x, y; complex(double x = 0, double y = 0) :x(x), y(y) &#123;&#125; friend complex operator +(complex a, complex b) &#123; return complex(a.x + b.x, a.y + b.y); &#125; friend complex operator -(complex a, complex b) &#123; return complex(a.x - b.x, a.y - b.y); &#125; friend complex operator *(complex a, complex b) &#123; return complex(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); &#125;&#125; 然后就是重头戏了： 单位根看上去非常高大上对不对 由于我们在上面说过，复数可以看做一个二维平面的向量，因此横轴表示实部，纵轴表示虚部。 那么我们在这上面画一个单位圆 从点$(1,0)$开始，逆时针将这$n$个点从$0$开始编号，第$k$个点记为$\\omega^k_n$，由复数辐角相加的运算法则可知，$\\omega^k_n$是$\\omega^1_n$的$k$次方，因此$\\omega_n^1$被称为$n$次单位根。 显然$\\omega^k_n$所对应的向量为$(cos\\dfrac {k2\\pi} n,sin\\dfrac {k2\\pi} n)$ 单位根的性质： 首先由定义可知： $\\omega^{2k}_{2n}=\\omega^k_n$ 然后由三角函数的性质可知 $\\omega^{k+\\frac n2}=-\\omega^k_n$ 由单位根的性质可得 把多项式A(x)的离散傅里叶变换结果作为另一个多项式B(x)的系数，取单位根的倒数即$\\omega^0_n$,$ω^{−1}_n$,$ω^{−2}_n$,…,$ω^{−(n−1)}_n$作为x代入B(x)，得到的每个数再除以n，得到的是A(x)的各项系数。这实现了傅里叶变换的逆变换——把点值表示转换成多项式系数表示，这就是离散傅里叶变换神奇的特殊性质。 证明略，想看的可以看这个 FFT是基于分治的原理，利用单位根的奇偶性来使复杂度达到优秀的$\\Theta(nlog_n)$，详细证明可以看上面给出的链接，这里不再赘述。 其实FFT并不需要背过原理也不需要会证明，因为过一段时间就忘了，所以只有记住代码就可以了，代码其实理解了原理再稍微看看就刻在$DNA$里了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#pragma region revive#include &lt;set&gt;#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#define inl inline#define re register int#define fa(x) t[x].fa#define son(x, y) t[x].child[y]#define ls(x) t[x].child[0]#define rs(x) t[x].child[1]#define ll long longconst int inf = 0x3f3f3f3f;#define lowbit(x) ((x) &amp; (-x))using namespace std;#ifndef _DEBUG#define getchar() (*(IOB.in.p++))#define putchar(c) (*(IOB.out.p++) = (c))#define io_eof() (IOB.in.p &gt;= IOB.in.pend)struct IOBUF &#123; struct &#123; char buff[1 &lt;&lt; 26], *p, *pend; &#125; in; struct &#123; char buff[1 &lt;&lt; 26], *p; &#125; out; IOBUF() &#123; in.p = in.buff; out.p = out.buff; in.pend = in.buff + fread(in.buff, 1, 1 &lt;&lt; 27, stdin); &#125; ~IOBUF() &#123; fwrite(out.buff, 1, out.p - out.buff, stdout); &#125;&#125; IOB;#endiftemplate &lt;typename IO&gt;inl void write(IO x) &#123; if (x == 0) return (void)putchar('0'); if (x &lt; 0) putchar('-'), x = -x; static char buf[30]; char *p = buf; while (x) &#123; *(p++) = x % 10 + '0'; x /= 10; &#125; while (p &gt; buf) putchar(*(--p));&#125;inl void writestr(const char *s) &#123; while (*s != 0) putchar(*(s++));&#125;template &lt;typename IO&gt;inl void writeln(IO x) &#123; write(x), putchar('\\n'); &#125;template &lt;typename IO&gt;inl void writesp(IO x) &#123; write(x), putchar(' '); &#125;inl int readstr(char *s) &#123; char *begin = s, c = getchar(); while (c &lt; 33 || c &gt; 127) &#123; c = getchar(); &#125; while (c &gt;= 33 &amp;&amp; c &lt;= 127) &#123; *(s++) = c; c = getchar(); &#125; *s = 0; return s - begin;&#125;template &lt;typename IO&gt;inl IO read() &#123; IO x = 0; register bool w = 0; register char c = getchar(); while (c &gt; '9' || c &lt; '0') &#123; if (c == '-') w = 1; c = getchar(); &#125; while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); c = getchar(); &#125; return w ? -x : x;&#125;template &lt;&gt;inl double read&lt;double&gt;() &#123; double x = 0; int w = 0, y = 0; ll z = 1; register char c = getchar(); while (c &gt; '9' || c &lt; '0') &#123; if (c == '-') w = 1; c = getchar(); &#125; while (c &gt;= '0' &amp;&amp; c &lt;= '9' || c == '.') &#123; if (c == '.') &#123; y = 1, c = getchar(); continue; &#125; x = x * 10 + (c ^ 48); if (y) z *= 10; c = getchar(); &#125; return (w ? -x : x) / z;&#125;#pragma endregionconst int N = 4e6 + 1;struct complex &#123; double x, y; complex(double x = 0, double y = 0) :x(x), y(y) &#123;&#125; friend complex operator +(complex a, complex b) &#123; return complex(a.x + b.x, a.y + b.y); &#125; friend complex operator -(complex a, complex b) &#123; return complex(a.x - b.x, a.y - b.y); &#125; friend complex operator *(complex a, complex b) &#123; return complex(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); &#125;&#125;a[N], b[N];const double Pi = acos(-1.0);int rev[N], lim = 1, lg;inl void FFT(complex *a, double op) &#123; for (re i = 0; i &lt; lim; i++)if (i &lt; rev[i])swap(a[i], a[rev[i]]); for (re mid = 1; mid &lt; lim; mid &lt;&lt;= 1) &#123; complex W(cos(Pi / mid), op * sin(Pi / mid)); for (re r = mid &lt;&lt; 1, j = 0; j &lt; lim; j += r) &#123; complex w(1, 0); for (re k = 0; k &lt; mid; k++, w = w * W) &#123; complex x = a[j + k], y = w * a[j + k + mid]; a[j + k] = x + y; a[j + k + mid] = x - y; &#125; &#125; &#125;&#125;signed main() &#123; re n = read&lt;int&gt;(), m = read&lt;int&gt;(); for (re i = 0; i &lt;= n; i++)a[i].x = read&lt;int&gt;(); for (re i = 0; i &lt;= m; i++)b[i].x = read&lt;int&gt;(); while (lim &lt;= n + m)lim &lt;&lt;= 1, lg++; for (re i = 0; i &lt; lim; i++)rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (lg - 1)); FFT(a, 1), FFT(b, 1); for (re i = 0; i &lt; lim; i++)a[i] = a[i] * b[i]; FFT(a, -1); for (re i = 0, j = n + m; i &lt;= j; i++)writesp((int)(a[i].x / lim + 0.5));&#125; NTT就是把FFT从复数域拉回了整数域，避免了精度的损失，同时能更方便的处理取模，常数也更小，就是把单位根通过数论的知识换成了原根，具体证明我不会，同时NTT对模数有很苛刻的要求，基本常用的就那么几个 998244353 1004535809 469762049 这些模数必须是满足可以写成$r*2^k+1$的形式的质数 原根g的定义：就是一个在$\\text{mod p}$意义下，g的所有次幂正好对应了0到$p-1$内所有的数。 这个性质非常的棒，可以在特定情况下把乘变成g的指数相加 求原根的方法： 12345678910111213141516171819inl void ordm(int m) &#123; re n = m - 1; for (re i = 2; i*i &lt; n; i++) &#123; if (n%i == 0) &#123; fac[++cnt] = i; while (n%i == 0)n /= i; &#125; &#125; if (n - 1)fac[++cnt] = n; for (re i = 2; i &lt; m; i++) &#123; bool flag = true; for (re j = 1; j &lt;= cnt; j++) &#123; if (qpow(i, (m - 1) / fac[j], m) == 1) &#123; flag = false; break; &#125; &#125; if (flag) &#123; G = i; break; &#125; &#125;&#125; NTT就是把FFT单位根换成了原根，这样理解就够用了。 代码： 12345678910111213141516inl void NTT(int *a, int lim, int op = 1) &#123; for (re i = 1; i &lt; lim; i++)if (i &lt; rev[i]) swap(a[i], a[rev[i]]); for (re mid = 1, r = 2; mid &lt; lim; mid &lt;&lt;= 1, r &lt;&lt;= 1) &#123; re g = qpow(op == 1 ? G : iG, (p - 1) / r);//iG为G在模P意义下的逆元 for (re j = 0; j &lt; lim; j += r) &#123; for (re k = 0, gn = 1, x, y; k &lt; mid; k++, gn = 1ll * g * gn % p) &#123; x = a[j + k], y = 1ll * a[j + k + mid] * gn % p; a[j + k] = (x + y) % p, a[j + k + mid] = (x - y + p) % p; &#125; &#125; &#125; if (op != 1) &#123; re inv = qpow(lim, p - 2); for (re i = 0; i &lt; lim; i++) a[i] = 1ll * a[i] * inv % p; &#125;&#125; 例题：​ 已经学会了多项式乘法，我们就可以开始做题了，多项式乘法的题目最大的特点和难点就是要把题目给的信息抽象成一个卷积的形式，主要难点在化式子。 luogu P3338 luogu P3321 luogu P5488 luogu P3723 先写到这里，剩下的有时间再补上","categories":[],"tags":[{"name":"多项式","slug":"多项式","permalink":"http://Geiz-Revive.github.io/tags/多项式/"}]},{"title":"CF633H-Fibonacci-ish-II","slug":"CF633H-Fibonacci-ish-II","date":"2019-08-05T02:02:15.000Z","updated":"2019-08-05T02:03:00.347Z","comments":true,"path":"2019/08/05/CF633H-Fibonacci-ish-II/","link":"","permalink":"http://Geiz-Revive.github.io/2019/08/05/CF633H-Fibonacci-ish-II/","excerpt":"","text":"莫队+线段树维护矩乘，复杂度$\\Theta(T^3n\\sqrt nlogn)$，也可以二次离线达到$\\Theta(n\\sqrt n)$的复杂度。 挺不错的题，除了卡常和放了暴力过去之外都挺好的，看到没有正解的题解，我就来发一发。 我们考虑加入一个数造成的影响，后面的数的矩阵都全部要乘以一个斐波那契递推的矩阵，我们考虑在权值线段树上维护，然后打上标记维护即可，细节挺多的，然后删除一个数就是后面的数乘一个逆矩阵即可。 因为本题卡常，所以离散化后立即取模，避免用$long long$，减少不必要的取模，尽量精简函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#pragma region revive#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define inl inline#define re register int#define fa(x) fa[x]#define son(x, y) t[x].child[y]#define ls(x) child[x][0]#define rs(x) child[x][1]#define ll long longconst int inf = 0x3f3f3f3f;const ll Linf = 0x3f3f3f3f3f3f3f3fLL;#define lowbit(x) ((x) &amp; (-x))using namespace std;#ifndef _DEBUG#define getchar() (*(IOB.in.p++))#define putchar(c) (*(IOB.out.p++) = (c))#define io_eof() (IOB.in.p &gt;= IOB.in.pend)struct IOBUF &#123; struct &#123; char buff[1 &lt;&lt; 27], *p, *pend; &#125; in; struct &#123; char buff[1 &lt;&lt; 27], *p; &#125; out; IOBUF() &#123; in.p = in.buff; out.p = out.buff; in.pend = in.buff + fread(in.buff, 1, 1 &lt;&lt; 27, stdin); &#125; ~IOBUF() &#123; fwrite(out.buff, 1, out.p - out.buff, stdout); &#125;&#125; IOB;#endiftemplate &lt;typename IO&gt;inl void write(IO x) &#123; if (x == 0) return (void)putchar('0'); if (x &lt; 0) putchar('-'), x = -x; static char buf[30]; char *p = buf; while (x) &#123; *(p++) = x % 10 + '0'; x /= 10; &#125; while (p &gt; buf) putchar(*(--p));&#125;inl void writestr(const char *s) &#123; while (*s != 0) putchar(*(s++));&#125;template &lt;typename IO&gt;inl void writeln(IO x) &#123; write(x), putchar('\\n'); &#125;template &lt;typename IO&gt;inl void writesp(IO x) &#123; write(x), putchar(' '); &#125;inl int readstr(char *s) &#123; char *begin = s, c = getchar(); while (c &lt; 33 || c &gt; 127) &#123; c = getchar(); &#125; while (c &gt;= 33 &amp;&amp; c &lt;= 127) &#123; *(s++) = c; c = getchar(); &#125; *s = 0; return s - begin;&#125;template &lt;typename IO&gt;inl IO read() &#123; IO x = 0; register bool w = 0; register char c = getchar(); while (c &gt; '9' || c &lt; '0') &#123; if (c == '-') w = 1; c = getchar(); &#125; while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); c = getchar(); &#125; return w ? -x : x;&#125;#pragma endregionint s[30001], n, p, siz, mp[30001], a[30001], b[30001], cnt[30001];ll ans[30001];struct quiz &#123; int l, r, id; bool operator&lt;(const quiz&amp; a)const &#123; return s[l] == s[a.l] ? s[l] &amp; 1 ? r&lt;a.r : r&gt;a.r : s[l] &lt; s[a.l]; &#125;&#125;q[30001];struct matrix &#123; int a[2][2]; matrix() &#123; a[0][0] = 1, a[1][0] = a[0][1] = 0, a[1][1] = 1; &#125; matrix(int x) &#123; if (x == 1)a[0][0] = 1, a[1][0] = 1, a[0][1] = 1, a[1][1] = 0; else if (!x)a[0][0] = a[0][1] = a[1][0] = a[1][1] = 0; else a[0][0] = 0, a[0][1] = 1, a[1][0] = 1, a[1][1] = -1; &#125; inl int* operator[](int x) &#123; return a[x]; &#125; inl const int* operator[](int x) const &#123; return a[x]; &#125; friend matrix operator*(const matrix &amp;a, const matrix &amp;b) &#123; matrix c = matrix(0); for (re i = 0; i &lt; 2; i++) &#123; for (re j = 0; j &lt; 2; j++) &#123; for (re k = 0; k &lt; 2; k++) &#123; c[i][j] += a[i][k] * b[k][j]; &#125; &#125; &#125; for (re i = 0; i &lt; 2; i++) &#123; for (re j = 0; j &lt; 2; j++) &#123; c[i][j] %= p; &#125; &#125; return c; &#125; friend matrix operator+(const matrix &amp;a, const matrix &amp;b) &#123; matrix c = matrix(0); for (re i = 0; i &lt; 2; i++) &#123; for (re j = 0; j &lt; 2; j++) &#123; c[i][j] += a[i][j] + b[i][j]; &#125; &#125; for (re i = 0; i &lt; 2; i++) &#123; for (re j = 0; j &lt; 2; j++) &#123; c[i][j] %= p; &#125; &#125; return c; &#125; matrix operator*(int x) &#123; for (re i = 0; i &lt; 2; i++) &#123; for (re j = 0; j &lt; 2; j++) &#123; a[i][j] = a[i][j] * x; &#125; &#125; for (re i = 0; i &lt; 2; i++) &#123; for (re j = 0; j &lt; 2; j++) &#123; a[i][j] %= p; &#125; &#125; return *this; &#125; friend bool operator==(const matrix &amp;a, const matrix &amp;b) &#123; for (re i = 0; i &lt; 2; i++) &#123; for (re j = 0; j &lt; 2; j++) &#123; if (a[i][j] != b[i][j])return 0; &#125; &#125; return 1; &#125; friend bool operator!=(const matrix &amp;a, const matrix &amp;b) &#123; return !(a == b); &#125;&#125;E = matrix(), G = matrix(1), R = matrix(-1);struct node &#123; int w; matrix tag, ans;&#125;t[120001];inl void upd(int k) &#123; matrix a = t[k &lt;&lt; 1].ans, b = t[k &lt;&lt; 1 | 1].ans; if (t[k &lt;&lt; 1].w != 1)a = a * t[k &lt;&lt; 1].w; if (t[k &lt;&lt; 1 | 1].w != 1)b = b * t[k &lt;&lt; 1 | 1].w; t[k].ans = a + b;&#125;inl void build(int k, int l, int r) &#123; t[k].w = l != r; if (l == r)return (void)(t[k].ans = G); re mid = l + r &gt;&gt; 1; build(k &lt;&lt; 1, l, mid), build(k &lt;&lt; 1 | 1, mid + 1, r); upd(k);&#125;inl void mul(int k, matrix w) &#123; t[k].ans = t[k].ans*w, t[k].tag = t[k].tag*w;&#125;inl void pushdown(int k) &#123; if (t[k].tag != E) &#123; mul(k &lt;&lt; 1, t[k].tag), mul(k &lt;&lt; 1 | 1, t[k].tag); t[k].tag = E; &#125;&#125;inl void insert(int k, int l, int r, int p) &#123; if (l == r) return (void)(t[k].w = mp[p]); pushdown(k); re mid = l + r &gt;&gt; 1; if (p &lt;= mid)insert(k &lt;&lt; 1, l, mid, p), mul(k &lt;&lt; 1 | 1, G); else insert(k &lt;&lt; 1 | 1, mid + 1, r, p); upd(k);&#125;inl void erase(int k, int l, int r, int p) &#123; if (l == r) return (void)(t[k].w = 0); pushdown(k); re mid = l + r &gt;&gt; 1; if (p &lt;= mid)erase(k &lt;&lt; 1, l, mid, p), mul(k &lt;&lt; 1 | 1, R); else erase(k &lt;&lt; 1 | 1, mid + 1, r, p); upd(k);&#125;inl void add(int x) &#123; if (!cnt[x]++) insert(1, 1, siz, x);&#125;inl void del(int x) &#123; if (!--cnt[x]) erase(1, 1, siz, x);&#125;signed main() &#123; n = read&lt;int&gt;(), p = read&lt;int&gt;(); for (re i = 1; i &lt;= n; i++)a[i] = b[i] = read&lt;int&gt;(); sort(b + 1, b + 1 + n); siz = unique(b + 1, b + 1 + n) - b - 1; re m = read&lt;int&gt;(), num = sqrt(n); for (re i = 1; i &lt;= n; i++) &#123; re k = a[i]; mp[a[i] = lower_bound(b + 1, b + 1 + siz, a[i]) - b] = k % p; &#125; for (re i = 1; i &lt;= 30000; i++)s[i] = (i - 1) / num + 1; for (re i = 1; i &lt;= m; i++) q[i].l = read&lt;int&gt;(), q[i].r = read&lt;int&gt;(), q[i].id = i; sort(q + 1, q + 1 + m); build(1, 1, siz); re l = 1, r = 0; for (re i = 1; i &lt;= m; i++) &#123; while (l &gt; q[i].l)add(a[--l]); while (r &lt; q[i].r)add(a[++r]); while (l &lt; q[i].l)del(a[l++]); while (r &gt; q[i].r)del(a[r--]); ans[q[i].id] = t[1].ans[0][1]%p; &#125; for (re i = 1; i &lt;= m; i++)writeln((ans[i] % p + p) % p);&#125;","categories":[],"tags":[{"name":"莫队","slug":"莫队","permalink":"http://Geiz-Revive.github.io/tags/莫队/"}]},{"title":"动态dp学习笔记","slug":"动态dp学习笔记","date":"2019-08-03T07:10:29.000Z","updated":"2019-08-03T11:14:08.073Z","comments":true,"path":"2019/08/03/动态dp学习笔记/","link":"","permalink":"http://Geiz-Revive.github.io/2019/08/03/动态dp学习笔记/","excerpt":"","text":"动态$dp$是指有修改的$dp$问题，通常的解决方法是把转移方程写成矩阵，然后用数据结构维护矩阵连乘积，这里的乘法是重定义的运算，取决于原dp问题的转移方程。比如最大子段和就是求和再取$max$。 但是维护连乘积的前提条件是在序列上，如果是在树上，就需要通过一些技巧转化为序列问题。 $\\Large 例题\\alpha$： 先来一道比较水的： $Link$ $n$ 个数，$q$ 次操作$(n,q\\le50000)$ 操作0 x y$A_x$ 修改为$y$ 操作1 l r询问区间$[l,r]$ 的最大子段和 $\\large Solution 1:$ 显然可以用线段树维护前后缀的最大和来解决，这里不再占用篇幅。 $\\large Solution 2:$ 考虑原转移方程的形式：$dp_i=max(dp_{i-1}+a[i],a[i]),ans=max(ans,dp_{i-1}+a[i],a[i])$ 所以矩阵就可以写出来了： $\\left( \\begin{matrix} tmp_{i-1}&amp;ans_{i-1}&amp;0\\end{matrix} \\right)\\left( \\begin{matrix}a_i&amp;a_i&amp;-inf\\ -inf&amp;0&amp;-inf\\ a_i&amp;a_i&amp;0\\end{matrix} \\right) = \\left( \\begin{matrix} tmp_{i}&amp;ans_{i}&amp;0\\end{matrix} \\right)$ 我们将平常的矩阵乘法换成这样的形式$c[i][j]=max_k(a[i][k]+b[k][j])$ 线段树维护那个大矩阵连乘积即可，修改就是把每个位置上的$a_i$改了再$pushup$ $\\Large 例题\\beta$： $Link$ 给定一棵$n$个点的树，点带点权。 有$m$次操作，每次操作给定$x,y$表示修改点$x$的权值为$y$。 你需要在每次操作之后求出这棵树的最大权独立集的权值大小。 没有修改肯定都会做，方程是： $dp_{u,0}=\\sum\\limits_{v∈uson}max(dp_{v,0},dp_{v,1}),dp_{u,1}=val_u+\\sum\\limits_{v∈uson}dp_{v,0}$ 其中$v$是$u$的儿子 重点在于如何把这个方程转化到能在序列上使用。 我们发现这个东西似乎可以变换一下顺序也没什么影响，所以我们可以一条重链一条重链的dp，每次到达一个重链的顶部的时候我们直接将这个重链全部塞到队列里，然后我们递归下去遍历和重链相连的所有重链，最后处理这个重链。 然后对于重链上的每个点，先根据轻儿子的$dp$值(因为轻儿子一定是其他重链的顶部所以dp值必定已经计算好)，计算出一个$ldp_{i,0/1}$，然后根据这个$ldp$值在重链上跑序列$dp$。 方程为：$ldp_{u,0}=\\sum\\limits_{v∈lightson}max(dp_{v,0},dp_{v,1}),ldp_{u,1}=\\sum\\limits_{v∈lightson}dp_{v,0}$ 之后可以得到：$dp_{u,0}=max(dp_{heavy,0},dp_{heavy,1})+ldp_{u,0},dp_{u,1}=val_u+ldp_{u,1}+dp_{heavy,0}$ 矩乘形式同上，矩阵为： $\\left( \\begin{matrix}dp_{i-1,0}&amp;dp_{i-1,1}\\end{matrix} \\right)\\left( \\begin{matrix}ldp_{i,0}&amp;ldp_{i,1}\\ldp_{i,0}&amp;-∞\\end{matrix} \\right) = \\left( \\begin{matrix}dp_{i,0}&amp;dp_{i,1} \\end{matrix} \\right)$ 树剖就可以$nlog^2n$维护了 但是还有一个$log$的黑科技：“全局平衡二叉树”，也就是所谓的静态$lct$ 以下引用自shadowice1984大佬的题解： 1234567891011121314151617181920212223242526众所周知把刚才的树剖换成lct就可以做到一个log了，但是我们发现lct实在是常数太!大!了！绝对是跑不过实现的优秀的一点的树剖的但是我们对于lct的复杂度证明却很感兴趣，为啥同样是操作了logn个数据结构，把线段树换成常数更大的splay复杂度反而少了一个log呢？(刚才这句话严格来讲是病句，常数和复杂度没有任何关联)具体证明需要用到势能分析，但是感性理解一下就是如果我们把lct上的虚边也看成splay的边的话，我们发现整棵lct变成了一棵大splay，只是有些点度数不是2了但是这些点度不是2的点并未破坏splay的势能分析换句话说势能分析对整颗大splay仍然生效, 所以你的log次splay在整个大splay上只是一次splay而已复杂度自然是均摊O(logn)了但是，我们发现这是颗静态树，使用splay实在是大(常)材(数)小(过)用(大)了于是我们考虑将lct强行静态化，换句话说，建一个像splay一样的全局平衡的树观察到线段树只是局部平衡的，在碰到专业卡链剖的数据--链式堆(根号n个长度为根号n的链连成完全二叉树的形状)的时候会导致算上虚边之后的整颗树左倾或者右倾此时我们发现如果在建线段树的时候做点手脚，我们把线段树换成二叉查找树bst，并且这个bst不是严格平衡的话，我们可以做到更加优秀的复杂度，使得算上虚边之后的树树高达到O(logn)级别我们还是在树上dfs，但是对于重链建bst的时候我们并不建一个完美的bst，而是将每一个节点附上一个权值，权值为它所有轻儿子的siz之和 + 1，然后我们每次找这个链的带权重心，把他作为这一级的父亲，然后递归两边进行建bst。当然我们发现最坏情况下我们可以建出一个严重左倾或者右倾的bst。但是，我们考虑算上虚边的整颗树我们会发现一个神奇的性质，无论是经过一条重的二叉树边还是虚边，所在子树的siz至少翻一倍，而这个性质在原来的线段树上是没有的所以这个大bst的高度是O(logn)的 写起来还是挺好写的。 $\\Large 建树部分:$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768struct matrix &#123; int a[2][2]; matrix() &#123; a[0][0] = a[1][0] = a[0][1] = a[1][1] = -inf; &#125; matrix(bool x) &#123; a[0][0] = a[1][1] = 0, a[0][1] = a[1][0] = -inf; &#125; friend matrix operator*(matrix a, matrix b) &#123; matrix c; for (re i = 0; i &lt; 2; i++) &#123; for (re j = 0; j &lt; 2; j++) &#123; for (re k = 0; k &lt; 2; k++) &#123; c[i][j] = max(c[i][j], a[i][k] + b[k][j]); &#125; &#125; &#125; return c; &#125; inl int *operator[](int x) &#123; return a[x]; &#125; inl int getmax() &#123; return max(&#123; a[0][0], a[1][0], a[0][1], a[1][1] &#125;); &#125;&#125;;int siz[100001], h[100001];vector&lt;int&gt; ve[100001];inl void dfs(int x) &#123; siz[x] = 1; for (auto y : ve[x]) &#123; if (!siz[y]) &#123; dfs(y), siz[x] += siz[y], siz[y] &gt; siz[h[x]] ? h[x] = y : 0; &#125; &#125;&#125;int ew[100001], v[100001], st[100001], top, rt;bool vis[100001];struct node &#123; int child[2], fa; matrix mul, w;&#125; t[100001];inl void pushup(int x) &#123; t[x].mul = t[ls(x)].mul * t[x].w * t[rs(x)].mul;&#125;inl void upd(int x, int y) &#123; t[x].w[0][0] = (t[x].w[0][1] += t[y].mul.getmax()); t[x].w[1][0] += max(t[y].mul[0][0], t[y].mul[0][1]); fa(y) = x;&#125;inl int build(int l, int r) &#123; if (l &gt; r) return 0; re sum = 0; for (re i = l; i &lt;= r; i++) sum += ew[st[i]]; for (re i = l, now = ew[st[i]]; i &lt;= r; now += ew[st[++i]]) &#123; if ((now &lt;&lt; 1) &gt;= sum) &#123; ls(st[i]) = build(l, i - 1), rs(st[i]) = build(i + 1, r), pushup(st[i]); if (ls(st[i])) fa(ls(st[i])) = st[i]; if (rs(st[i])) fa(rs(st[i])) = st[i]; return st[i]; &#125; &#125; return 0;&#125;inl int build(int x) &#123; for (re i = x; i; i = h[i]) ew[i] = siz[i] - siz[h[i]], vis[i] = 1; for (re i = x; i; i = h[i]) &#123; for (auto y : ve[i]) &#123; if (!vis[y]) upd(i, build(y)); &#125; &#125; top = 0; for (re i = x; i; i = h[i])st[++top] = i; return build(1, top);&#125; $\\Large 修改：$ 12345678910111213141516inl bool isroot(int x) &#123; return ls(fa(x)) != x &amp;&amp; rs(fa(x)) != x;&#125;inl void modify(int x, int w) &#123; t[x].w[1][0] += w - v[x], v[x] = w; for (re i = x; i; i = fa(i)) &#123; if (isroot(i) &amp;&amp; fa(i)) &#123; t[fa(i)].w[0][1] = (t[fa(i)].w[0][0] -= t[i].mul.getmax()); t[fa(i)].w[1][0] -= max(t[i].mul[0][1], t[i].mul[0][0]); pushup(i); t[fa(i)].w[0][1] = (t[fa(i)].w[0][0] += t[i].mul.getmax()); t[fa(i)].w[1][0] += max(t[i].mul[0][1], t[i].mul[0][0]); &#125; pushup(i); &#125;&#125; 复杂度达到了优秀的一个$log$，并且常数也挺小的，跑的确实比树剖快，用这个就可以过掉强化版了。 强化版link $\\Large 例题\\gamma$： 这题算是老熟人了……，$noip2018D2T3$ 保卫王国 动态$dp$板子题啊，把刚才的模板题稍微改一下就可以了（然而我还是重新写了一遍），本题所求即为总权值-带权最大独立集权值，修改就是改成正负$inf$，随便改一下就过了，当然也可以重新推个式子，式子也是非常的好推，这里就不在展示了。 先写这么多，由于现在找不到题单，之后可能会更新。。。","categories":[],"tags":[{"name":"动态dp","slug":"动态dp","permalink":"http://Geiz-Revive.github.io/tags/动态dp/"}]},{"title":"SP1716-GSS3","slug":"SP1716-GSS3","date":"2019-08-03T07:10:04.000Z","updated":"2019-08-03T07:34:09.145Z","comments":true,"path":"2019/08/03/SP1716-GSS3/","link":"","permalink":"http://Geiz-Revive.github.io/2019/08/03/SP1716-GSS3/","excerpt":"","text":"题意就是要求区间最大子段和，带修。 维护前缀最大和后缀最大的思路由前几个GSS系列的题继承过来就行了，这里讲一点有意思的东西。 因为最近刚好在学习动态dp，这题正好也算是个典型，就又做了一遍。 动态dp是把正常的状态转移方程转化成矩阵的形式，然后用数据结构维护矩阵的连乘积。当然这里的矩阵乘法不是正常的矩阵乘法，重定义后的矩乘长这个亚子： 12345678910111213struct matrix&#123; ...&#125;;matrix operator* (matrix a,matrix b)&#123; matrix c; for(int i...)&#123; for(int j...)&#123; for(int k...)&#123; c[i][j]=max(c[i][j],a[i][k]+b[k][j]); &#125; &#125; &#125;&#125; 也就是把乘变成了加，把加变成了取$max$ 最大子段和的状态转移方程大概是这样的： 1234for(int i=1;i&lt;=n;i++)&#123; tmp=max(tmp+a[i],a[i]); ans=max(ans,tmp);&#125; 所以我们构造出的矩阵长这样: $\\left( \\begin{matrix} tmp_{i-1}&amp;ans_{i-1}&amp;0\\end{matrix} \\right)\\left( \\begin{matrix}a_i&amp;a_i&amp;-inf\\ -inf&amp;0&amp;-inf\\ a_i&amp;a_i&amp;0\\end{matrix} \\right) = \\left( \\begin{matrix} tmp_{i}&amp;ans_{i}&amp;0\\end{matrix} \\right)$ 我们只要用线段树维护这个矩阵的连乘积：$\\left( \\begin{matrix}a_i&amp;a_i&amp;-inf\\ -inf&amp;0&amp;-inf\\ a_i&amp;a_i&amp;0\\end{matrix} \\right)$ 每次修改把四个$a_i$全部改掉，然后$pushup$就好了。 $\\Large Code$ : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#pragma region revive#include &lt;set&gt;#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#define inl inline#define re register int#define fa(x) fa[x]#define son(x, y) t[x].child[y]#define ls(x) child[x][0]#define rs(x) child[x][1]#define ll long longconst int inf = 0x3f3f3f3f;#define lowbit(x) ((x) &amp; (-x))using namespace std;#ifndef _DEBUG#define getchar() (*(IOB.in.p++))#define putchar(c) (*(IOB.out.p++) = (c))#define io_eof() (IOB.in.p &gt;= IOB.in.pend)struct IOBUF &#123; struct &#123; char buff[1 &lt;&lt; 26], *p, *pend; &#125; in; struct &#123; char buff[1 &lt;&lt; 26], *p; &#125; out; IOBUF() &#123; in.p = in.buff; out.p = out.buff; in.pend = in.buff + fread(in.buff, 1, 1 &lt;&lt; 27, stdin); &#125; ~IOBUF() &#123; fwrite(out.buff, 1, out.p - out.buff, stdout); &#125;&#125; IOB;#endiftemplate &lt;typename IO&gt;inl void write(IO x) &#123; if (x == 0) return (void)putchar('0'); if (x &lt; 0) putchar('-'), x = -x; static char buf[30]; char *p = buf; while (x) &#123; *(p++) = x % 10 + '0'; x /= 10; &#125; while (p &gt; buf) putchar(*(--p));&#125;inl void writestr(const char *s) &#123; while (*s != 0) putchar(*(s++));&#125;template &lt;typename IO&gt;inl void writeln(IO x) &#123; write(x), putchar('\\n'); &#125;template &lt;typename IO&gt;inl void writesp(IO x) &#123; write(x), putchar(' '); &#125;inl int readstr(char *s) &#123; char *begin = s, c = getchar(); while (c &lt; 33 || c &gt; 127) &#123; c = getchar(); &#125; while (c &gt;= 33 &amp;&amp; c &lt;= 127) &#123; *(s++) = c; c = getchar(); &#125; *s = 0; return s - begin;&#125;template &lt;typename IO&gt;inl IO read() &#123; IO x = 0; register bool w = 0; register char c = getchar(); while (c &gt; '9' || c &lt; '0') &#123; if (c == '-') w = 1; c = getchar(); &#125; while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); c = getchar(); &#125; return w ? -x : x;&#125;template&lt;&gt;inl double read&lt;double&gt;() &#123; double x = 0; int w = 0, y = 0; ll z = 1; register char c = getchar(); while (c &gt; '9' || c &lt; '0') &#123; if (c == '-') w = 1; c = getchar(); &#125; while (c &gt;= '0' &amp;&amp; c &lt;= '9' || c == '.') &#123; if (c == '.') &#123; y = 1, c = getchar(); continue; &#125; x = x * 10 + (c ^ 48); if (y)z *= 10; c = getchar(); &#125; return (w ? -x : x) / z;&#125;#pragma endregionstruct matrix &#123; int a[3][3]; matrix() &#123; a[0][0] = a[0][1] = a[0][2] = a[1][0] = a[1][1] = a[1][2] = a[2][0] = a[2][1] = a[2][2] = -inf; &#125; matrix(bool x) &#123; a[0][0] = a[1][1] = a[2][2] = 0, a[0][1] = a[0][2] = a[1][0] = a[1][2] = a[2][0] = a[2][1] = -inf; &#125; inl int *operator[](int x) &#123; return a[x]; &#125; inl const int *operator[](int x) const &#123; return a[x]; &#125; friend matrix operator*(const matrix &amp;a, const matrix &amp;b) &#123; matrix c; for (re i = 0; i &lt; 3; i++) &#123; for (re j = 0; j &lt; 3; j++) &#123; for (re k = 0; k &lt; 3; k++) &#123; c[i][j] = max(c[i][j], a[i][k] + b[k][j]); &#125; &#125; &#125; return c; &#125; inl int getmax() &#123; return max(a[0][1], a[2][1]); &#125;&#125;t[200001];inl void upd(int k) &#123; t[k] = t[k &lt;&lt; 1] * t[k &lt;&lt; 1 | 1];&#125;inl void build(int k, int l, int r) &#123; if (l == r) return (void)(t[k][0][0] = t[k][0][1] = t[k][2][0] = t[k][2][1] = read&lt;int&gt;(), t[k][1][1] = t[k][2][2] = 0); re mid = l + r &gt;&gt; 1; build(k &lt;&lt; 1, l, mid), build(k &lt;&lt; 1 | 1, mid + 1, r); upd(k);&#125;inl void change(int k, int l, int r, int p, int w) &#123; if (l == r)return (void)(t[k][0][0] = t[k][0][1] = t[k][2][0] = t[k][2][1] = w); re mid = l + r &gt;&gt; 1; if (p &lt;= mid)change(k &lt;&lt; 1, l, mid, p, w); else change(k &lt;&lt; 1 | 1, mid + 1, r, p, w); upd(k);&#125;inl matrix query(int k, int l, int r, int x, int y) &#123; if (l &gt;= x &amp;&amp; r &lt;= y)return t[k]; re mid = l + r &gt;&gt; 1; matrix ans = matrix(0); if (x &lt;= mid)ans = ans * query(k &lt;&lt; 1, l, mid, x, y); if (y &gt; mid)ans = ans * query(k &lt;&lt; 1 | 1, mid + 1, r, x, y); return ans;&#125;signed main() &#123; re n = read&lt;int&gt;(), m, op, x, y; build(1, 1, n); m = read&lt;int&gt;(); while (m--) &#123; op = read&lt;int&gt;(), x = read&lt;int&gt;(), y = read&lt;int&gt;(); if (op) &#123; writeln(query(1, 1, n, x, y).getmax()); &#125; else &#123; change(1, 1, n, x, y); &#125; &#125;&#125;","categories":[],"tags":[{"name":"动态dp","slug":"动态dp","permalink":"http://Geiz-Revive.github.io/tags/动态dp/"}]},{"title":"杜教筛学习笔记","slug":"杜教筛学习笔记","date":"2019-07-18T08:42:35.000Z","updated":"2019-08-19T11:33:28.596Z","comments":true,"path":"2019/07/18/杜教筛学习笔记/","link":"","permalink":"http://Geiz-Revive.github.io/2019/07/18/杜教筛学习笔记/","excerpt":"","text":"狄利克雷卷积 定义：对于函数$f(n)$和$g(n)$，$(f\\ast g)(n)=\\sum\\limits_{d|n} f(d)g(\\dfrac{n}{d})$ 常见完全积性函数： 元函数 $\\epsilon(n)=[n=1]$ 单位函数$id(n)=n$ 常数函数$1(n)=1$ 常见卷积： 1： 因为$\\sum\\limits_{d|n}\\mu(d)=[n=1]=\\epsilon$ 所以两边卷个1得到$\\mu \\ast 1=\\epsilon$ 然后我们可以得出$\\sum\\limits_{i=1}^n(1*\\mu)=1$ 2： 因为$\\sum\\limits_{d|n}\\phi(d)=n=id(n)$ 所以卷个1得到$\\phi\\ast1=id$ 然后可以得到$\\sum\\limits_{i=1}^n(1*\\phi)=\\sum\\limits_{i=1}^nid(i)=\\dfrac{n\\ast (n+1)}{2}$ 3 : 因为$\\phi\\ast1=id$ 两边卷个$\\mu$得到$\\phi * 1 * \\mu=id\\ast\\mu$ $\\phi\\ast\\epsilon=id\\ast\\mu$ $\\phi(n)=\\sum\\limits_{d|n}\\mu(d)\\times\\dfrac{n}{d}$ 两边同除以$n$得$\\dfrac{\\phi(n)}{n}=\\sum\\limits_{d|n}\\dfrac{\\mu(d)}{d}$ 4 : $\\sum\\limits_{i=1}^ni^k\\ast\\phi(i)$ 卷上$id^k$得$\\sum\\limits_{d|n}d^k\\phi(d)*(\\dfrac{n}{d})^k=n^k$ 杜教筛其实就是一个式子： $g(1)S(n)=\\sum\\limits_{i=1}^n(f\\ast g)-\\sum\\limits_{i=2}^ng(i)S(\\dfrac{n}{i})$ 杜教筛用于快速求前缀和，复杂度似乎是$\\Theta(n^{\\frac{2}{3}})$，然而我并不会证明。 有了这个式子，我们就可以利用一个好算的卷积前缀和递归求解一个和式。 由上面的常见卷积1可得：$S(n)=\\sum\\limits_{i=1}^n\\epsilon(i)-\\sum\\limits_{i=2}^nS(\\dfrac{n}{i})=1-\\sum\\limits_{i=2}^nS(\\dfrac{n}{i})$ 后面那个式子显然可以整除分块。 其他的同理。 例题 咕","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://Geiz-Revive.github.io/tags/数学/"}]},{"title":"虚树学习笔记","slug":"虚树学习笔记","date":"2019-07-16T13:36:20.000Z","updated":"2019-08-07T06:39:02.874Z","comments":true,"path":"2019/07/16/虚树学习笔记/","link":"","permalink":"http://Geiz-Revive.github.io/2019/07/16/虚树学习笔记/","excerpt":"","text":"虚树用来解决询问多个关键点，且关键点总数不多的一类问题，记每次询问的关键点个数为$n$，通常$\\sum_{n}\\le 1e5$是用到虚树的题目的共性。当树上部分节点用处不大的时候，我们可以把它们从树上删掉，只保留关键点和它们的$LCA$。虚树的点数级别是$\\Theta(n)$的，因为只包含了$n$个关键点以及它们的$LCA$，所以总点数最多是$2n-1$个。构造虚树： 首先我们需要把$LCA$预处理出来，可以用$ST$表或者树链剖分，顺便处理出树的$dfs$序。 将询问的关键点按照$dfs$序排序，为了方便我们先把根加入数组中，求出相邻两点的$LCA$，加入关键点数组中重新再按照$dfs$序排序，并去重，现在我们已经得到了虚树上所有的点的前序遍历。 如果当前点在栈顶子树中 将栈顶和当前点连边，并将当前点入栈。 如果当前点不在栈顶子树中，说明此时栈顶所在的一段链已经$Dfs$完毕，弹栈，重复执行该过程直到满足情况1。 $\\Large Code:$ 12345678910111213141516171819202122inl void build() &#123; memset(head, 0, sizeof(head)), tot = 0; sort(a.begin(), a.end(), [](int a, int b) -&gt; bool &#123;return dfn[a] &lt; dfn[b]; &#125;); int tmp = a.size(); for (int i = 0; i &lt; tmp - 1; i++) a.push_back(lca(a[i], a[i + 1])); sort(a.begin(), a.end(), [](int a, int b) -&gt; bool &#123;return dfn[a] &lt; dfn[b]; &#125;); auto it = unique(a.begin(), a.end()); a.erase(it, a.end()); rt = st[++top] = a[0]; for (int i = 1; i &lt; a.size(); i++) &#123; int now = a[i]; while (top &gt;= 1) &#123; if (fir[now] &gt;= fir[st[top]] &amp;&amp; fir[now] &lt;= las[st[top]]) &#123; add(st[top], now); break; &#125; top--; &#125; if (st[top] != now) st[++top] = now; &#125;&#125;","categories":[],"tags":[{"name":"虚树","slug":"虚树","permalink":"http://Geiz-Revive.github.io/tags/虚树/"}]},{"title":"洛谷-P3242-接水果","slug":"洛谷-P3242-接水果","date":"2019-07-15T08:07:54.000Z","updated":"2019-07-15T08:08:48.293Z","comments":true,"path":"2019/07/15/洛谷-P3242-接水果/","link":"","permalink":"http://Geiz-Revive.github.io/2019/07/15/洛谷-P3242-接水果/","excerpt":"","text":"$\\Large \\color{rgb(0,255,255)}Describe$ 树上莫队 + 值域分块，复杂度$\\Theta(n\\sqrt n+nlogn)$ 我们把一个盘子看做是两个点，然后当在莫队同时加入这个两个点时，我们就相应的把这个盘子加入值域分块中，删除同理。用一个$vector$维护每个点上带着的盘子。 值域分块的$trick$和这个题一样，查询$\\sqrt n$，加入删除都是$\\Theta(1)$的，和莫队的复杂度摊掉了，然后看到$1e9$的值域很显然是要离散化，然后这题差不多就做完了。 本蒟蒻做的时候$LCA$写错调了好久，希望各位不要犯这种睿智错误，$LCA$用的是$\\Theta(nlogn)/\\Theta(1)$$LCA$ $\\Large Code:$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#pragma region revive#include &lt;set&gt;#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#define inl inline#define re register int#define fa(x) t[x].fa#define son(x, y) t[x].child[y]#define ls(x) t[x].child[0]#define rs(x) t[x].child[1]#define ll long longconst int inf = 0x3f3f3f3f;#define lowbit(x) ((x) &amp; (-x))using namespace std;#ifndef _DEBUG#define getchar() (*(IOB.in.p++))#define putchar(c) (*(IOB.out.p++) = (c))#define io_eof() (IOB.in.p &gt;= IOB.in.pend)struct IOBUF &#123; struct &#123; char buff[1 &lt;&lt; 26], *p, *pend; &#125; in; struct &#123; char buff[1 &lt;&lt; 26], *p; &#125; out; IOBUF() &#123; in.p = in.buff; out.p = out.buff; in.pend = in.buff + fread(in.buff, 1, 1 &lt;&lt; 26, stdin); &#125; ~IOBUF() &#123; fwrite(out.buff, 1, out.p - out.buff, stdout); &#125;&#125; IOB;#endiftemplate &lt;typename IO&gt;inl void write(IO x) &#123; if (x == 0) return (void)putchar('0'); if (x &lt; 0) putchar('-'), x = -x; static char buf[30]; char *p = buf; while (x) &#123; *(p++) = x % 10 + '0'; x /= 10; &#125; while (p &gt; buf) putchar(*(--p));&#125;inl void writestr(const char *s) &#123; while (*s != 0) putchar(*(s++));&#125;template &lt;typename IO&gt;inl void writeln(IO x) &#123; write(x), putchar('\\n'); &#125;template &lt;typename IO&gt;inl void writesp(IO x) &#123; write(x), putchar(' '); &#125;inl int readstr(char *s) &#123; char *begin = s, c = getchar(); while (c &lt; 33 || c &gt; 127) &#123; c = getchar(); &#125; while (c &gt;= 33 &amp;&amp; c &lt;= 127) &#123; *(s++) = c; c = getchar(); &#125; *s = 0; return s - begin;&#125;template &lt;typename IO&gt;inl IO read() &#123; IO x = 0; register bool w = 0; register char c = getchar(); while (c &gt; '9' || c &lt; '0') &#123; if (c == '-') w = 1; c = getchar(); &#125; while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); c = getchar(); &#125; return w ? -x : x;&#125;#pragma endregionint f[100001][20], dep[50001], st[50001], ed[50001], o[100001], euler[100001], head[50001], mp[100001], lg[100001], len, tot, num, a[100001], b[100001], t[100001];vector&lt;int&gt; ve[40001];struct edge &#123; int next, to;&#125; e[100001];inl void adde(int x, int y) &#123; e[++tot] = edge&#123; head[x], y &#125;, head[x] = tot; e[++tot] = edge&#123; head[y], x &#125;, head[y] = tot;&#125;inl void dfs(int x, int fa) &#123; euler[++euler[0]] = x, o[++len] = x, st[x] = euler[0], mp[x] = len, dep[x] = dep[fa] + 1; for (re i = head[x]; i; i = e[i].next) &#123; if (e[i].to != fa) &#123; dfs(e[i].to, x); o[++len] = x; &#125; &#125; euler[++euler[0]] = x, ed[x] = euler[0];&#125;inl int lca(int l, int r) &#123; l = mp[l], r = mp[r]; re x = min(l, r), y = max(l, r), k = lg[y - x + 1]; l = x, r = y; return dep[f[l][k]] &lt; dep[f[r - (1 &lt;&lt; k) + 1][k]] ? f[l][k] : f[r - (1 &lt;&lt; k) + 1][k];&#125;int s[100001], sum[1001], sz[1001], cnt[100001], buc[100001], ans[100001];inl void init() &#123; dfs(1, 0); for (re i = 2; i &lt;= len; i++)lg[i] = lg[i &gt;&gt; 1] + 1; for (re i = 1; i &lt;= len; i++)f[i][0] = o[i]; for (re j = 1; j &lt;= lg[len]; j++) &#123; for (re i = 1; i + (1 &lt;&lt; j) - 1 &lt;= len; i++) &#123; f[i][j] = dep[f[i][j - 1]] &lt; dep[f[i + (1 &lt;&lt; (j - 1))][j - 1]] ? f[i][j - 1] : f[i + (1 &lt;&lt; (j - 1))][j - 1]; &#125; &#125; num = sqrt(euler[0]); for (re i = 1; i &lt;= euler[0]; i++)s[i] = (i - 1) / num + 1, sz[s[i]]++;&#125;bool vis[100001];struct quiz &#123; int l, r, k, lca, id; bool operator&lt;(const quiz &amp;a) &#123; return s[l] == s[a.l] ? s[l] &amp; 1 ? r &lt; a.r : r &gt; a.r : s[l] &lt; s[a.l]; &#125;&#125; q[100001];inl void add(int x) &#123; for (auto i : ve[x])((++buc[i]) == 2) ? (cnt[a[i]]++, sum[s[a[i]]]++) : 0;&#125;inl void del(int x) &#123; for (auto i : ve[x])(buc[i] == 2) ? (cnt[a[i]]--, buc[i]--, sum[s[a[i]]]--) : (buc[i]--);&#125;inl void oper(int x) &#123; (vis[x] ^= 1) ? add(x) : del(x);&#125;signed main() &#123; re n = read&lt;int&gt;(), p = read&lt;int&gt;(), m = read&lt;int&gt;(), x, y, w, f; for (re i = 1; i &lt; n; i++) x = read&lt;int&gt;(), y = read&lt;int&gt;(), adde(x, y); init(); for (re i = 1; i &lt;= p; i++) &#123; x = read&lt;int&gt;(), y = read&lt;int&gt;(), w = read&lt;int&gt;(); ve[x].push_back(i), ve[y].push_back(i), a[i] = b[i] = w; &#125; sort(b + 1, b + 1 + p); re siz = unique(b + 1, b + 1 + p) - b - 1; for (re i = 1; i &lt;= p; i++) &#123; re k = a[i]; t[a[i] = lower_bound(b + 1, b + 1 + siz, a[i]) - b] = k; &#125; for (re i = 1; i &lt;= m; i++) &#123; x = read&lt;int&gt;(), y = read&lt;int&gt;(), w = read&lt;int&gt;(); if (st[x] &gt; st[y]) swap(x, y); f = lca(x, y); if (x != f) q[i] = quiz&#123; ed[x], st[y], w, f, i &#125;; else q[i] = quiz&#123; st[x], st[y], w, 0, i &#125;; &#125; sort(q + 1, q + 1 + m); re l = 1, r = 0, res = 0; for (re i = 1; i &lt;= m; i++) &#123; while (l &lt; q[i].l)oper(euler[l++]); while (l &gt; q[i].l)oper(euler[--l]); while (r &lt; q[i].r)oper(euler[++r]); while (r &gt; q[i].r)oper(euler[r--]); if (q[i].lca) oper(q[i].lca); res = 0; for (re j = 1; j &lt;= s[siz]; j++) &#123; if (res + sum[j] &lt; q[i].k)res += sum[j]; else &#123; for (re l = (j - 1) * num + 1, r = l + sz[j] - 1; l &lt;= r; l++) &#123; if ((res += cnt[l]) &gt;= q[i].k) &#123; ans[q[i].id] = t[l]; goto begin; &#125; &#125; &#125; &#125; begin: if (q[i].lca)oper(q[i].lca); &#125; for (re i = 1; i &lt;= m; i++)writeln(ans[i]);&#125;","categories":[],"tags":[{"name":"莫队","slug":"莫队","permalink":"http://Geiz-Revive.github.io/tags/莫队/"}]},{"title":"CF785E-Anton-and-Permutation","slug":"CF785E-Anton-and-Permutation","date":"2019-06-21T07:43:18.000Z","updated":"2019-06-21T08:04:18.587Z","comments":true,"path":"2019/06/21/CF785E-Anton-and-Permutation/","link":"","permalink":"http://Geiz-Revive.github.io/2019/06/21/CF785E-Anton-and-Permutation/","excerpt":"","text":"$\\Large \\color{Green}{Describe}$ 题意 ：对于一个长度为$n$$(n\\le 200000)$的序列进行$q$$(q \\le 50000)$次操作，每次操作都是交换序列中的某两个数。对于每一个操作，回答当前序列中有多少个逆序对。 本题是一个三维偏序问题，所求即为满足$pos_i&gt;pos_j 且 val_i&lt;val_j$$或$$pos_i&lt;pos_j 且 val_i&gt;val_j$的$(i,j)$​的对数。 我们考虑每次交换操作，可以拆成两个删除和两个插入，先减去贡献，然后在原位置删除，再交换两个值的$pos$，之后在新位置插入，再加上现在的贡献，这样就做完了$……$吗？ 写出来会发现样例都过不了，原因是我们在这样处理时会额外计算一些贡献 当交换后这两个数产生了一对逆序对时，$ans$- - 当交换后这两个数减少了一对逆序对时，$ans$++ 因为当交换后产生了一对逆序对时，加贡献会把这一对加两遍，同理减少了一对时减贡献会减两遍。 然后就是上树状数组套动态开点权值线段树，时空复杂度均是$\\Theta(nlog^2_n)$ $\\Large Code:$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#pragma region revive#include &lt;set&gt;#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#define inl inline#define re register int#define fa(x) t[x].fa#define son(x,y) t[x].child[y]#define ls(x) t[x].child[0]#define rs(x) t[x].child[1]#define ll long longconst int inf = 0x3f3f3f3f;#define lowbit(x) ((x) &amp; (-x))using namespace std;#ifndef _DEBUG#define getchar() (*(IOB.in.p++))#define putchar(c) (*(IOB.out.p++)=(c))#define io_eof() (IOB.in.p&gt;=IOB.in.pend)struct IOBUF &#123; struct &#123; char buff[1 &lt;&lt; 26], *p, *pend; &#125;in; struct &#123; char buff[1 &lt;&lt; 26], *p; &#125;out; IOBUF() &#123; in.p = in.buff; out.p = out.buff; in.pend = in.buff + fread(in.buff, 1, 1 &lt;&lt; 26, stdin); &#125;~IOBUF() &#123; fwrite(out.buff, 1, out.p - out.buff, stdout); &#125; &#125;IOB;#endiftemplate&lt;typename IO&gt;inl void write(IO x) &#123; if (x == 0) return (void)putchar('0'); if (x &lt; 0)putchar('-'), x = -x; static char buf[30]; char* p = buf; while (x) &#123; *(p++) = x % 10 + '0'; x /= 10; &#125; while (p &gt; buf)putchar(*(--p));&#125;inl void writestr(const char *s) &#123; while (*s != 0)putchar(*(s++)); &#125;template&lt;typename IO&gt;inl void writeln(IO x) &#123; write(x), putchar('\\n'); &#125;template&lt;typename IO&gt;inl void writesp(IO x) &#123; write(x), putchar(' '); &#125;inl int readstr(char *s) &#123; char *begin = s, c = getchar(); while (c &lt; 33 || c&gt;127) &#123; c = getchar(); &#125; while (c &gt;= 33 &amp;&amp; c &lt;= 127) &#123; *(s++) = c; c = getchar(); &#125; *s = 0; return s - begin;&#125;template&lt;typename IO&gt;inl IO read() &#123; IO x = 0; register bool w = 0; register char c = getchar(); while (c &gt; '9' || c &lt; '0') &#123; if (c == '-') w = 1; c = getchar(); &#125; while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); c = getchar(); &#125; return w ? -x : x;&#125;#pragma endregion#undef ls#undef rs#define ls(x) t[x].l#define rs(x) t[x].rint root[1000001], cnt, pos[1000001], tmpl[51], tmpr[51], cntl, cntr, n;struct node &#123; int w, l, r;&#125;t[20000001];inl void maintain(int x) &#123; t[x].w = t[ls(x)].w + t[rs(x)].w;&#125;inl void change(int &amp;k, int l, int r, int p, int w) &#123; if (!k)k = ++cnt; if (l == r)return (void)(t[k].w += w); re mid = l + r &gt;&gt; 1; if (p &lt;= mid)change(ls(k), l, mid, p, w); else change(rs(k), mid + 1, r, p, w); maintain(k);&#125;inl int query(int l, int r, int x, bool op) &#123; cntl = cntr = 0; for (re i = l - 1; i; i -= lowbit(i)) tmpl[++cntl] = root[i]; for (re i = r; i; i -= lowbit(i))tmpr[++cntr] = root[i]; l = 1, r = n; re mid, ans = 0; while (l != r) &#123; mid = l + r &gt;&gt; 1; if (x &lt;= mid) &#123; if (op) &#123; for (re i = 1; i &lt;= cntl; i++)ans -= t[rs(tmpl[i])].w; for (re i = 1; i &lt;= cntr; i++)ans += t[rs(tmpr[i])].w; &#125; for (re i = 1; i &lt;= cntl; i++)tmpl[i] = ls(tmpl[i]); for (re i = 1; i &lt;= cntr; i++)tmpr[i] = ls(tmpr[i]); r = mid; &#125; else &#123; if (!op) &#123; for (re i = 1; i &lt;= cntl; i++)ans -= t[ls(tmpl[i])].w; for (re i = 1; i &lt;= cntr; i++)ans += t[ls(tmpr[i])].w; &#125; for (re i = 1; i &lt;= cntl; i++)tmpl[i] = rs(tmpl[i]); for (re i = 1; i &lt;= cntr; i++)tmpr[i] = rs(tmpr[i]); l = mid + 1; &#125; &#125; return ans;&#125;signed main() &#123; n = read&lt;int&gt;(); re m = read&lt;int&gt;(), x, y; ll ans = 0; for (re i = 1; i &lt;= n; i++) &#123; pos[i] = i; for (re j = i; j &lt;= n; j += lowbit(j)) change(root[j], 1, n, i, 1); &#125; while (m--) &#123; x = read&lt;int&gt;(), y = read&lt;int&gt;(); if (x == y) &#123; writeln(ans); continue; &#125; ans -= query(1, pos[x] - 1, x, 1) + query(pos[x] + 1, n, x, 0); ans -= query(1, pos[y] - 1, y, 1) + query(pos[y] + 1, n, y, 0); for (re i = pos[x]; i &lt;= n; i += lowbit(i))change(root[i], 1, n, x, -1); for (re i = pos[y]; i &lt;= n; i += lowbit(i))change(root[i], 1, n, y, -1); swap(pos[x], pos[y]); for (re i = pos[x]; i &lt;= n; i += lowbit(i))change(root[i], 1, n, x, 1); for (re i = pos[y]; i &lt;= n; i += lowbit(i))change(root[i], 1, n, y, 1); ans += query(1, pos[x] - 1, x, 1) + query(pos[x] + 1, n, x, 0); ans += query(1, pos[y] - 1, y, 1) + query(pos[y] + 1, n, y, 0); ans -= (pos[x] &gt; pos[y] &amp;&amp; x &lt; y) || (pos[x] &lt; pos[y] &amp;&amp; x &gt; y); ans += (pos[x] &gt; pos[y] &amp;&amp; x &gt; y) || (pos[x] &lt; pos[y] &amp;&amp; x &lt; y); writeln(ans); &#125;&#125;","categories":[],"tags":[{"name":"主席树","slug":"主席树","permalink":"http://Geiz-Revive.github.io/tags/主席树/"}]},{"title":"CF474F-Ant-Colony","slug":"CF474F-Ant-Colony","date":"2019-06-20T08:38:21.000Z","updated":"2019-06-20T08:51:16.431Z","comments":true,"path":"2019/06/20/CF474F-Ant-Colony/","link":"","permalink":"http://Geiz-Revive.github.io/2019/06/20/CF474F-Ant-Colony/","excerpt":"","text":"$\\Large\\color{pink}{Describe}$ 这题的题意是要求出不能整除区间内所有数的个数，正难则反一下就变成了区间长度减去能整除区间内所有数的个数，显然这个数就是区间的$gcd$（窝太菜了一开始还以为可以是$gcd$的约数，后来发现是窝傻了），然后就可以发现这个$sum$跟$gcd$是具有可加性的，之后就大力上线段树就完事了。 目前是本题最优解，欢迎超越。 维护部分的代码： 123456node operator +(node a, node b) &#123; node c; c.gcd = gcd(a.gcd, b.gcd); c.sum = (a.gcd == c.gcd)*a.sum + (b.gcd == c.gcd)*b.sum; return c;&#125; $\\large Code:$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#pragma region revive#include &lt;set&gt;#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#define inl inline#define re register int#define fa(x) t[x].fa#define son(x,y) t[x].child[y]#define ls(x) t[x].child[0]#define rs(x) t[x].child[1]#define ll long longconst int inf = 0x3f3f3f3f;#define lowbit(x) ((x) &amp; (-x))using namespace std;#ifndef _DEBUG#define getchar() (*(IOB.in.p++))#define putchar(c) (*(IOB.out.p++)=(c))#define io_eof() (IOB.in.p&gt;=IOB.in.pend)struct IOBUF &#123; struct &#123; char buff[1 &lt;&lt; 26], *p, *pend; &#125;in; struct &#123; char buff[1 &lt;&lt; 26], *p; &#125;out; IOBUF() &#123; in.p = in.buff; out.p = out.buff; in.pend = in.buff + fread(in.buff, 1, 1 &lt;&lt; 26, stdin); &#125;~IOBUF() &#123; fwrite(out.buff, 1, out.p - out.buff, stdout); &#125; &#125;IOB;#endiftemplate&lt;typename IO&gt;inl void write(IO x) &#123; if (x == 0) return (void)putchar('0'); if (x &lt; 0)putchar('-'), x = -x; static char buf[30]; char* p = buf; while (x) &#123; *(p++) = x % 10 + '0'; x /= 10; &#125; while (p &gt; buf)putchar(*(--p));&#125;inl void writestr(const char *s) &#123; while (*s != 0)putchar(*(s++)); &#125;template&lt;typename IO&gt;inl void writeln(IO x) &#123; write(x), putchar('\\n'); &#125;template&lt;typename IO&gt;inl void writesp(IO x) &#123; write(x), putchar(' '); &#125;inl int readstr(char *s) &#123; char *begin = s, c = getchar(); while (c &lt; 33 || c&gt;127) &#123; c = getchar(); &#125; while (c &gt;= 33 &amp;&amp; c &lt;= 127) &#123; *(s++) = c; c = getchar(); &#125; *s = 0; return s - begin;&#125;template&lt;typename IO&gt;inl IO read() &#123; IO x = 0; register bool w = 0; register char c = getchar(); while (c &gt; '9' || c &lt; '0') &#123; if (c == '-') w = 1; c = getchar(); &#125; while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); c = getchar(); &#125; return w ? -x : x;&#125;#pragma endregioninl int gcd(int x, int y) &#123; if (x &lt; y)swap(x, y); return y ? gcd(y, x%y) : x; &#125;struct node &#123; int gcd, sum;&#125;t[500001];node operator +(node a, node b) &#123; node c; c.gcd = gcd(a.gcd, b.gcd); c.sum = (a.gcd == c.gcd)*a.sum + (b.gcd == c.gcd)*b.sum; return c;&#125;int a[100001];inl void maintain(int x) &#123; t[x] = t[x &lt;&lt; 1] + t[x &lt;&lt; 1 | 1]; &#125;inl void build(int k, int l, int r) &#123; if (l == r) &#123; return (void)(t[k].gcd = a[l], t[k].sum = 1); &#125; re mid = l + r &gt;&gt; 1; build(k &lt;&lt; 1, l, mid), build(k &lt;&lt; 1 | 1, mid + 1, r); maintain(k);&#125;inl node query(int k, int l, int r, int x, int y) &#123; if (l &gt;= x &amp;&amp; r &lt;= y)return t[k]; re mid = l + r &gt;&gt; 1; node ans = &#123; 0,0 &#125;; if (x &lt;= mid)ans = ans + query(k &lt;&lt; 1, l, mid, x, y); if (y &gt; mid)ans = ans + query(k &lt;&lt; 1 | 1, mid + 1, r, x, y); return ans;&#125;signed main() &#123; re n = read&lt;int&gt;(), m; for (re i = 1; i &lt;= n; i++)a[i] = read&lt;int&gt;(); build(1, 1, n); m = read&lt;int&gt;(); while (m--) &#123; re x = read&lt;int&gt;(), y = read&lt;int&gt;(); writeln(y - x + 1 - query(1, 1, n, x, y).sum); &#125;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://Geiz-Revive.github.io/tags/线段树/"}]},{"title":"CF827D-BestEdgeWeight","slug":"CF827D-BestEdgeWeight","date":"2019-06-20T07:39:15.000Z","updated":"2019-06-20T07:41:05.036Z","comments":true,"path":"2019/06/20/CF827D-BestEdgeWeight/","link":"","permalink":"http://Geiz-Revive.github.io/2019/06/20/CF827D-BestEdgeWeight/","excerpt":"","text":"$\\Large\\color{orange}{Describe}$ 题意是要求出一条边的边权为多大时，能出现在所有的最小生成树中，因此我们先随便造一棵最小生成树，进行分类讨论。 对于非树边，它的答案是它链接的这两个点在最小生成树上的链的最大值再-1，这样它才能替换掉树边。 对于树边，它的答案是能够让它所链接的两个点联通的非树边的最小值再减一，否则它会被替换掉。 之后可以发现，我们需要的只不过是一个能查询链上最大值、链上取最小值的一个数据结构，因此树剖$\\Theta(nlog^2_n)$，LCT $\\Theta(nlog_n)$ $\\large Code:$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#pragma region revive#include &lt;set&gt;#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#define inl inline#define re register int#define fa(x) t[x].fa#define son(x,y) t[x].child[y]#define ls(x) t[x].child[0]#define rs(x) t[x].child[1]#define ll long longconst int inf = 0x3f3f3f3f;#define lowbit(x) ((x) &amp; (-x))using namespace std;#ifndef _DEBUG#define getchar() (*(IOB.in.p++))#define putchar(c) (*(IOB.out.p++)=(c))#define io_eof() (IOB.in.p&gt;=IOB.in.pend)struct IOBUF &#123; struct &#123; char buff[1 &lt;&lt; 26], *p, *pend; &#125;in; struct &#123; char buff[1 &lt;&lt; 26], *p; &#125;out; IOBUF() &#123; in.p = in.buff; out.p = out.buff; in.pend = in.buff + fread(in.buff, 1, 1 &lt;&lt; 26, stdin); &#125;~IOBUF() &#123; fwrite(out.buff, 1, out.p - out.buff, stdout); &#125; &#125;IOB;#endiftemplate&lt;typename IO&gt;inl void write(IO x) &#123; if (x == 0) return (void)putchar('0'); if (x &lt; 0)putchar('-'), x = -x; static char buf[30]; char* p = buf; while (x) &#123; *(p++) = x % 10 + '0'; x /= 10; &#125; while (p &gt; buf)putchar(*(--p));&#125;inl void writestr(const char *s) &#123; while (*s != 0)putchar(*(s++)); &#125;template&lt;typename IO&gt;inl void writeln(IO x) &#123; write(x), putchar('\\n'); &#125;template&lt;typename IO&gt;inl void writesp(IO x) &#123; write(x), putchar(' '); &#125;inl int readstr(char *s) &#123; char *begin = s, c = getchar(); while (c &lt; 33 || c&gt;127) &#123; c = getchar(); &#125; while (c &gt;= 33 &amp;&amp; c &lt;= 127) &#123; *(s++) = c; c = getchar(); &#125; *s = 0; return s - begin;&#125;template&lt;typename IO&gt;inl IO read() &#123; IO x = 0; register bool w = 0; register char c = getchar(); while (c &gt; '9' || c &lt; '0') &#123; if (c == '-') w = 1; c = getchar(); &#125; while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); c = getchar(); &#125; return w ? -x : x;&#125;#pragma endregionint fa[1000001], ans[1000001];bool vis[1000001];struct node &#123; int child[2], fa, w, max, tag; bool filp;&#125;t[1000001];inl void maintain(int x) &#123; t[x].max = max(&#123; t[ls(x)].max, t[rs(x)].max, t[x].w &#125;);&#125;inl bool poi(int x) &#123; return rs(fa(x)) == x; &#125;inl bool nroot(int x) &#123; return ls(fa(x)) == x || rs(fa(x)) == x; &#125;inl void reverse(int x) &#123; swap(ls(x), rs(x)), t[x].filp ^= 1; &#125;inl void change(int x, int w) &#123; ans[x] = min(ans[x], w), t[x].tag = min(t[x].tag, w); &#125;inl void rotate(int x) &#123; re f = fa(x), gf = fa(f), fs = poi(x), gfs = poi(f), s = t[x].child[fs ^ 1]; if (nroot(f))t[gf].child[gfs] = x; t[x].child[fs ^ 1] = f, t[f].child[fs] = s; if (s)fa(s) = f; fa(f) = x, fa(x) = gf, maintain(f);&#125;inl void pushdown(int x) &#123; if (t[x].filp) &#123; if (ls(x))reverse(ls(x)); if (rs(x))reverse(rs(x)); t[x].filp = 0; &#125; if (t[x].tag != inf) &#123; if (ls(x))change(ls(x), t[x].tag); if (rs(x))change(rs(x), t[x].tag); t[x].tag = inf; &#125;&#125;inl void push(int x) &#123; if (nroot(x))push(fa(x)); pushdown(x);&#125;inl void splay(int x) &#123; push(x); while (nroot(x)) &#123; if (nroot(fa(x)))poi(x) == poi(fa(x)) ? rotate(fa(x)) : rotate(x); rotate(x); &#125; maintain(x);&#125;inl void access(int x) &#123; for (re i = 0; x; x = fa(i = x)) splay(x), rs(x) = i, maintain(x);&#125;inl void makeroot(int x) &#123; access(x), splay(x), reverse(x);&#125;inl void split(int x, int y) &#123; makeroot(y), access(x), splay(x);&#125;inl void link(int x, int y) &#123; split(x, y), fa(y) = x;&#125;struct edge &#123; int u, v, w, id; bool operator &lt;(const edge &amp;fff)const &#123; return w &lt; fff.w; &#125;&#125;e[1000001];inl int find(int x) &#123; return fa[x] ? fa[x] = find(fa[x]) : x; &#125;signed main() &#123; re n = read&lt;int&gt;(), m = read&lt;int&gt;(), u, v, w = n + m, now; for (re i = 1; i &lt;= w; i++)t[i].tag = ans[i] = inf; for (re i = 1; i &lt;= m; i++) u = read&lt;int&gt;(), v = read&lt;int&gt;(), w = read&lt;int&gt;(), e[i] = edge&#123; u,v,w &#125;, e[i].id = i; sort(e + 1, e + 1 + m); for (re i = 1; i &lt;= m; i++) &#123; u = e[i].u, v = e[i].v, w = e[i].w, now = e[i].id + n; if (find(u) != find(v)) &#123; fa[find(v)] = u; t[now].w = t[now].max = w; link(u, now), link(v, now), vis[now] = 1; &#125; else &#123; split(u, v); ans[now] = t[u].max - 1; change(u, w); &#125; &#125; for (re i = n + 1, k = n + m; i &lt;= k; i++) &#123; if (vis[i]) &#123; access(i), splay(i), writesp(ans[i] == inf ? -1 : ans[i] - 1); &#125; else &#123; writesp(ans[i]); &#125; &#125;&#125;","categories":[],"tags":[{"name":"LCT","slug":"LCT","permalink":"http://Geiz-Revive.github.io/tags/LCT/"}]},{"title":"洛谷-P4513-小白逛公园","slug":"洛谷-P4513-小白逛公园","date":"2019-06-19T09:26:41.000Z","updated":"2019-06-19T09:28:09.646Z","comments":true,"path":"2019/06/19/洛谷-P4513-小白逛公园/","link":"","permalink":"http://Geiz-Revive.github.io/2019/06/19/洛谷-P4513-小白逛公园/","excerpt":"","text":"$\\Large\\color{violet}{Describe}$ 颓完文化课回来做水题能愉悦身心 题意就是单点修改，区间最大子段和，硬上线段树即可，维护是经典方法，如果换成区间修改也是可以做的。有兴趣可以去做一做$GSS$系列的题，最大子段和是个经典模型，尽量要掌握。 12345678node operator +(const node &amp;a, const node &amp;b) &#123; node c; c.tot = a.tot + b.tot; c.lsum = max(a.lsum, b.lsum + a.tot); c.rsum = max(b.rsum, a.rsum + b.tot); c.sum = max(&#123; a.sum,b.sum,a.rsum + b.lsum &#125;); return c;&#125; 其中$tot$代表原数列中的值的和，$sum$是最大子段和，$lsum$是最大前缀和，$rsum$是最大后缀和，维护想一想应该就很显然了。 $\\large Code:$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#pragma region revive#include &lt;set&gt;#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#define inl inline#define re register int#define fa(x) t[x].fa#define son(x,y) t[x].child[y]#define ls(x) t[x].child[0]#define rs(x) t[x].child[1]#define ll long longconst int inf = 0x3f3f3f3f;#define lowbit(x) ((x) &amp; (-x))using namespace std;#ifndef _DEBUG#define getchar() (*(IOB.in.p++))#define putchar(c) (*(IOB.out.p++)=(c))#define io_eof() (IOB.in.p&gt;=IOB.in.pend)struct IOBUF &#123; struct &#123; char buff[1 &lt;&lt; 26], *p, *pend; &#125;in; struct &#123; char buff[1 &lt;&lt; 26], *p; &#125;out; IOBUF() &#123; in.p = in.buff; out.p = out.buff; in.pend = in.buff + fread(in.buff, 1, 1 &lt;&lt; 26, stdin); &#125;~IOBUF() &#123; fwrite(out.buff, 1, out.p - out.buff, stdout); &#125; &#125;IOB;#endiftemplate&lt;typename IO&gt;inl void write(IO x) &#123; if (x == 0) return (void)putchar('0'); if (x &lt; 0)putchar('-'), x = -x; static char buf[30]; char* p = buf; while (x) &#123; *(p++) = x % 10 + '0'; x /= 10; &#125; while (p &gt; buf)putchar(*(--p));&#125;inl void writestr(const char *s) &#123; while (*s != 0)putchar(*(s++)); &#125;template&lt;typename IO&gt;inl void writeln(IO x) &#123; write(x), putchar('\\n'); &#125;template&lt;typename IO&gt;inl void writesp(IO x) &#123; write(x), putchar(' '); &#125;inl int readstr(char *s) &#123; char *begin = s, c = getchar(); while (c &lt; 33 || c&gt;127) &#123; c = getchar(); &#125; while (c &gt;= 33 &amp;&amp; c &lt;= 127) &#123; *(s++) = c; c = getchar(); &#125; *s = 0; return s - begin;&#125;template&lt;typename IO&gt;inl IO read() &#123; IO x = 0; register bool w = 0; register char c = getchar(); while (c &gt; '9' || c &lt; '0') &#123; if (c == '-') w = 1; c = getchar(); &#125; while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); c = getchar(); &#125; return w ? -x : x;&#125;#pragma endregion#undef ls#undef rs#define ls(x) ((x)&lt;&lt;1)#define rs(x) (ls(x)|1)struct node &#123; int lsum, rsum, sum, tot;&#125;t[10000001];node operator +(const node &amp;a, const node &amp;b) &#123; node c; c.tot = a.tot + b.tot; c.lsum = max(a.lsum, b.lsum + a.tot); c.rsum = max(b.rsum, a.rsum + b.tot); c.sum = max(&#123; a.sum,b.sum,a.rsum + b.lsum &#125;); return c;&#125;int a[1000001];inl void maintain(int x) &#123; t[x] = t[ls(x)] + t[rs(x)];&#125;inl void change(int k, int l, int r, int p, int w) &#123; if (l == r) return (void)(t[k].tot = t[k].sum = t[k].lsum = t[k].rsum = w); re mid = l + r &gt;&gt; 1; if (p &lt;= mid)change(ls(k), l, mid, p, w); else change(rs(k), mid + 1, r, p, w); maintain(k);&#125;inl void build(int k, int l, int r) &#123; if (l == r) return (void)(t[k].tot = t[k].sum = t[k].lsum = t[k].rsum = a[l]); re mid = l + r &gt;&gt; 1; build(ls(k), l, mid), build(rs(k), mid + 1, r); maintain(k);&#125;inl node query(int k, int l, int r, int x, int y) &#123; if (l &gt;= x &amp;&amp; r &lt;= y)return t[k]; re mid = l + r &gt;&gt; 1; node ans = &#123; 0,0,0,0 &#125;; if (x &lt;= mid) &#123; ans = query(ls(k), l, mid, x, y); if (y &gt; mid)ans = ans + query(rs(k), mid + 1, r, x, y); &#125; else if (y &gt; mid)ans = query(rs(k), mid + 1, r, x, y); return ans;&#125;signed main() &#123; re n = read&lt;int&gt;(), m = read&lt;int&gt;(), op, x, y; for (re i = 1; i &lt;= n; i++)a[i] = read&lt;int&gt;(); build(1, 1, n); while (m--) &#123; op = read&lt;int&gt;(), x = read&lt;int&gt;(), y = read&lt;int&gt;(); if (op == 1) &#123; if (x &gt; y)swap(x, y); writeln(query(1, 1, n, x, y).sum); &#125; else change(1, 1, n, x, y); &#125;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://Geiz-Revive.github.io/tags/线段树/"}]},{"title":"洛谷-P4374-Disruption","slug":"洛谷-P4374-Disruption","date":"2019-06-16T08:57:51.000Z","updated":"2019-06-16T09:10:28.939Z","comments":true,"path":"2019/06/16/洛谷-P4374-Disruption/","link":"","permalink":"http://Geiz-Revive.github.io/2019/06/16/洛谷-P4374-Disruption/","excerpt":"","text":"$\\large\\color{blue} {Describe}$ 蒟蒻回去颓了十天文化课以后回来的第一题。 分析题意可知，这题可以抽象成给链上的每条边赋值，每条边的权值为这个赋的值和原有值的最小值，然后就是板子了，树剖$log^2$，$LCT$ $log$，这里选择用$LCT$，因为要边转点所以常数还是挺大的。 还有就是注意初始化和要判断无解情况，初始化所有权值和标记为$inf$，统计答案时如果一条边的权为$inf$就输出$-1$ $\\large{Code}$： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#pragma region revive#include &lt;set&gt;#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#define inl inline#define re register int#define fa(x) t[x].fa#define son(x,y) t[x].child[y]#define ls(x) t[x].child[0]#define rs(x) t[x].child[1]#define ll long longconst int inf = 0x3f3f3f3f;#define lowbit(x) ((x) &amp; (-x))using namespace std;#ifndef _DEBUG#define getchar() (*(IOB.in.p++))#define putchar(c) (*(IOB.out.p++)=(c))#define io_eof() (IOB.in.p&gt;=IOB.in.pend)struct IOBUF &#123; struct &#123; char buff[1 &lt;&lt; 26], *p, *pend; &#125;in; struct &#123; char buff[1 &lt;&lt; 26], *p; &#125;out; IOBUF() &#123; in.p = in.buff; out.p = out.buff; in.pend = in.buff + fread(in.buff, 1, 1 &lt;&lt; 26, stdin); &#125;~IOBUF() &#123; fwrite(out.buff, 1, out.p - out.buff, stdout); &#125; &#125;IOB;#endiftemplate&lt;typename IO&gt;inl void write(IO x) &#123; if (x == 0) return (void)putchar('0'); if (x &lt; 0)putchar('-'), x = -x; static char buf[30]; char* p = buf; while (x) &#123; *(p++) = x % 10 + '0'; x /= 10; &#125; while (p &gt; buf)putchar(*(--p));&#125;inl void writestr(const char *s) &#123; while (*s != 0)putchar(*(s++)); &#125;template&lt;typename IO&gt;inl void writeln(IO x) &#123; write(x), putchar('\\n'); &#125;template&lt;typename IO&gt;inl void writesp(IO x) &#123; write(x), putchar(' '); &#125;inl int readstr(char *s) &#123; char *begin = s, c = getchar(); while (c &lt; 33 || c&gt;127) &#123; c = getchar(); &#125; while (c &gt;= 33 &amp;&amp; c &lt;= 127) &#123; *(s++) = c; c = getchar(); &#125; *s = 0; return s - begin;&#125;template&lt;typename IO&gt;inl IO read() &#123; IO x = 0; register bool w = 0; register char c = getchar(); while (c &gt; '9' || c &lt; '0') &#123; if (c == '-') w = 1; c = getchar(); &#125; while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); c = getchar(); &#125; return w ? -x : x;&#125;#pragma endregionstruct node &#123; int fa, child[2], w, tag; bool filp;&#125;t[1000001];inl void change(int x, int w) &#123; t[x].w = min(t[x].w, w), t[x].tag = min(t[x].tag, w);&#125;inl void reverse(int x) &#123; swap(ls(x), rs(x)), t[x].filp ^= 1;&#125;inl void pushdown(int x) &#123; if (t[x].filp) &#123; if (ls(x))reverse(ls(x)); if (rs(x))reverse(rs(x)); t[x].filp = 0; &#125; if (t[x].tag != inf) &#123; if (ls(x))change(ls(x), t[x].tag); if (rs(x))change(rs(x), t[x].tag); t[x].tag = inf; &#125;&#125;inl bool nroot(int x) &#123; return ls(fa(x)) == x || rs(fa(x)) == x; &#125;inl bool poi(int x) &#123; return rs(fa(x)) == x; &#125;inl void push(int x) &#123; if (nroot(x))push(fa(x)); pushdown(x);&#125;inl void rotate(int x) &#123; re f = fa(x), gf = fa(f), fs = poi(x), gfs = poi(f), s = t[x].child[fs ^ 1]; if (nroot(f))t[gf].child[gfs] = x; t[f].child[fs] = s, t[x].child[fs ^ 1] = f; if (s)fa(s) = f; fa(x) = gf, fa(f) = x;&#125;inl void splay(int x) &#123; push(x); while (nroot(x)) &#123; if (nroot(fa(x)))poi(x) == poi(fa(x)) ? rotate(fa(x)) : rotate(x); rotate(x); &#125;&#125;inl void access(int x) &#123; for (re i = 0; x; x = fa(i = x)) splay(x), rs(x) = i; &#125;inl void makeroot(int x) &#123; access(x), splay(x), reverse(x); &#125;inl void split(int x, int y) &#123; makeroot(y), access(x), splay(x); &#125;inl void link(int x, int y) &#123; split(x, y), fa(y) = x; &#125;struct edge &#123; int u, v;&#125;e[1000001];signed main() &#123; re n = read&lt;int&gt;(), m = read&lt;int&gt;(), x, y, w; for (re i = 0; i &lt;= n; i++)t[i].w = t[i + n].w = inf; for (re i = 1; i &lt; n; i++)x = read&lt;int&gt;(), y = read&lt;int&gt;(), e[i] = edge&#123; x,y &#125;, link(x, i + n), link(y, i + n); while (m--) &#123; x = read&lt;int&gt;(), y = read&lt;int&gt;(), w = read&lt;int&gt;(); split(x, y), change(x, w); &#125; for (re i = 1; i &lt; n; i++)split(e[i].u, e[i].v), writeln(t[i + n].w == inf ? -1 : t[i + n].w);&#125;","categories":[],"tags":[{"name":"LCT","slug":"LCT","permalink":"http://Geiz-Revive.github.io/tags/LCT/"}]},{"title":"洛谷 P4556 [Vani有约会] 雨天的尾巴","slug":"洛谷-P4556-Vani有约会-雨天的尾巴","date":"2019-06-04T10:36:03.000Z","updated":"2019-06-04T13:52:42.119Z","comments":true,"path":"2019/06/04/洛谷-P4556-Vani有约会-雨天的尾巴/","link":"","permalink":"http://Geiz-Revive.github.io/2019/06/04/洛谷-P4556-Vani有约会-雨天的尾巴/","excerpt":"","text":"线段树合并入门题（然而还是因为$sb$错误交了好几次），考虑每个节点建一棵动态开点的线段树，每次进行树上差分，这里给出一些主要代码片段： 更新： 123456inl void maintain(int x) &#123; if (t[ls(x)].w &gt;= t[rs(x)].w) &#123; t[x].w = t[ls(x)].w, t[x].c = t[ls(x)].c; &#125; else t[x].w = t[rs(x)].w, t[x].c = t[rs(x)].c;//c表示颜色，w表示权值&#125; 合并： 123456789101112inl int merge(int p, int q, int l, int r) &#123; if (!p || !q)return p + q; if (l == r) &#123; t[p].w += t[q].w, t[p].c = t[q].c; return p; &#125; re mid = l + r &gt;&gt; 1; ls(p) = merge(ls(p), ls(q), l, mid); rs(p) = merge(rs(p), rs(q), mid + 1, r); maintain(p); return p;&#125; 还有一个比较迷的点就是当我没有离散化时 12345678910111213141516inl void maintain(int x) &#123; if (t[ls(x)].w &gt;= t[rs(x)].w) &#123; t[x].w = t[ls(x)].w, t[x].c = t[ls(x)].c; &#125; else t[x].w = t[rs(x)].w, t[x].c = t[rs(x)].c; if(!t[x].w)t[x].c = 0;&#125;inl void solve(int x) &#123; for (re i = head[x]; i; i = e[i].next) &#123; if (e[i].to != fa[x]) &#123; solve(e[i].to); root[x] = merge(root[x], root[e[i].to], 1, s); &#125; &#125; ans[x] = t[root[x]].w;&#125; 这样写是对的 但是如果离散化以后，这样就只有95$pts$??? 于是乎经多次测试，离散化以后应该这样写： 123456789101112131415inl void maintain(int x) &#123; if (t[ls(x)].w &gt;= t[rs(x)].w) &#123; t[x].w = t[ls(x)].w, t[x].c = t[ls(x)].c; &#125; else t[x].w = t[rs(x)].w, t[x].c = t[rs(x)].c;&#125;inl void solve(int x) &#123; for (re i = head[x]; i; i = e[i].next) &#123; if (e[i].to != fa[x]) &#123; solve(e[i].to); root[x] = merge(root[x], root[e[i].to], 1, s); &#125; &#125; ans[x] = t[root[x]].w ? mp[t[root[x]].c] : 0;&#125; 我认为这两种写法应该是完全没有差别的，但是结果并不一样$emmm$。 全部代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#pragma region revive#include &lt;set&gt;#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#define inl inline#define re register int#define fa(x) t[x].fa#define son(x,y) t[x].child[y]#define ls(x) t[x].child[0]#define rs(x) t[x].child[1]#define ll long longconst int inf = 0x3f3f3f3f;#define lowbit(x) ((x) &amp; (-x))using namespace std;#ifndef _DEBUG#define getchar() (*(IOB.in.p++))#define putchar(c) (*(IOB.out.p++)=(c))#define io_eof() (IOB.in.p&gt;=IOB.in.pend)struct IOBUF &#123; struct &#123; char buff[1 &lt;&lt; 26], *p, *pend; &#125;in; struct &#123; char buff[1 &lt;&lt; 26], *p; &#125;out; IOBUF() &#123; in.p = in.buff; out.p = out.buff; in.pend = in.buff + fread(in.buff, 1, 1 &lt;&lt; 26, stdin); &#125;~IOBUF() &#123; fwrite(out.buff, 1, out.p - out.buff, stdout); &#125; &#125;IOB;#endiftemplate&lt;typename IO&gt;inl void write(IO x) &#123; if (x == 0) return (void)putchar('0'); if (x &lt; 0)putchar('-'), x = -x; static char buf[30]; char* p = buf; while (x) &#123; *(p++) = x % 10 + '0'; x /= 10; &#125; while (p &gt; buf)putchar(*(--p));&#125;inl void writestr(const char *s) &#123; while (*s != 0)putchar(*(s++)); &#125;template&lt;typename IO&gt;inl void writeln(IO x) &#123; write(x), putchar('\\n'); &#125;template&lt;typename IO&gt;inl void writesp(IO x) &#123; write(x), putchar(' '); &#125;inl int readstr(char *s) &#123; char *begin = s, c = getchar(); while (c &lt; 33 || c&gt;127) &#123; c = getchar(); &#125; while (c &gt;= 33 &amp;&amp; c &lt;= 127) &#123; *(s++) = c; c = getchar(); &#125; *s = 0; return s - begin;&#125;template&lt;typename IO&gt;inl IO read() &#123; IO x = 0; register bool w = 0; register char c = getchar(); while (c &gt; '9' || c &lt; '0') &#123; if (c == '-') w = 1; c = getchar(); &#125; while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); c = getchar(); &#125; return w ? -x : x;&#125;#pragma endregion#undef ls#undef rs#define ls(x) t[x].l#define rs(x) t[x].rint cnt, s;struct node &#123; int l, r, w, c;&#125;t[10000001];inl void maintain(int x) &#123; if (t[ls(x)].w &gt;= t[rs(x)].w) &#123; t[x].w = t[ls(x)].w, t[x].c = t[ls(x)].c; &#125; else t[x].w = t[rs(x)].w, t[x].c = t[rs(x)].c;&#125;inl void add(int &amp;k, int l, int r, int p, int w) &#123; if (!k)k = ++cnt; if (l == r) &#123; t[k].w += w, t[k].c = p; return; &#125; re mid = l + r &gt;&gt; 1; if (p &lt;= mid)add(ls(k), l, mid, p, w); else add(rs(k), mid + 1, r, p, w); maintain(k);&#125;inl int merge(int p, int q, int l, int r) &#123; if (!p || !q)return p + q; if (l == r) &#123; t[p].w += t[q].w, t[p].c = t[q].c; return p; &#125; re mid = l + r &gt;&gt; 1; ls(p) = merge(ls(p), ls(q), l, mid); rs(p) = merge(rs(p), rs(q), mid + 1, r); maintain(p); return p;&#125;int head[1000001], tot, top[1000001], dep[1000001], h[1000001], fa[1000001], siz[1000001], root[1000001], a[1000001], mp[1000001], ans[1000001];struct edge &#123; int next, to;&#125;e[1000001];inl void adde(int x, int y) &#123; e[++tot] = edge&#123; head[x],y &#125;, head[x] = tot; e[++tot] = edge&#123; head[y],x &#125;, head[y] = tot;&#125;inl void dfs1(int x) &#123; dep[x] = dep[fa[x]] + 1, siz[x] = 1; for (re i = head[x]; i; i = e[i].next) &#123; if (fa[x] != e[i].to) &#123; fa[e[i].to] = x; dfs1(e[i].to); siz[x] += siz[e[i].to]; siz[e[i].to] &gt; siz[h[x]] ? h[x] = e[i].to : 0; &#125; &#125;&#125;inl void dfs2(int x) &#123; if (h[x]) &#123; top[h[x]] = top[x]; dfs2(h[x]); &#125; for (re i = head[x]; i; i = e[i].next) &#123; if (!top[e[i].to]) &#123; top[e[i].to] = e[i].to; dfs2(e[i].to); &#125; &#125;&#125;inl int lca(int x, int y) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]])swap(x, y); x = fa[top[x]]; &#125; return dep[x] &lt; dep[y] ? x : y;&#125;inl void solve(int x) &#123; for (re i = head[x]; i; i = e[i].next) &#123; if (e[i].to != fa[x]) &#123; solve(e[i].to); root[x] = merge(root[x], root[e[i].to], 1, s); &#125; &#125; ans[x] = t[root[x]].w ? mp[t[root[x]].c] : 0;&#125;struct quiz &#123; int x, y, z;&#125;q[1000001];signed main() &#123; re n = read&lt;int&gt;(), m = read&lt;int&gt;(), x, y, z, f; top[1] = 1; for (re i = 1; i &lt; n; i++)adde(read&lt;int&gt;(), read&lt;int&gt;()); for (re i = 1; i &lt;= m; i++) x = read&lt;int&gt;(), y = read&lt;int&gt;(), a[i] = z = read&lt;int&gt;(), q[i] = quiz&#123; x,y,z &#125;; sort(a + 1, a + 1 + m); s = unique(a + 1, a + 1 + m) - a - 1; dfs1(1), dfs2(1); for (re i = 1, k; i &lt;= m; i++) k = q[i].z, mp[q[i].z = lower_bound(a + 1, a + 1 + s, q[i].z) - a] = k; for (re i = 1; i &lt;= m; i++) &#123; x = q[i].x, y = q[i].y, z = q[i].z, f = lca(x, y); add(root[x], 1, s, z, 1), add(root[y], 1, s, z, 1), add(root[f], 1, s, z, -1); if (fa[f])add(root[fa[f]], 1, s, z, -1); &#125; solve(1); for (re i = 1; i &lt;= n; i++)writeln(ans[i]);&#125;","categories":[],"tags":[{"name":"线段树合并","slug":"线段树合并","permalink":"http://Geiz-Revive.github.io/tags/线段树合并/"}]}]}