{"meta":{"title":"Geiz-Revive","subtitle":null,"description":null,"author":"Geiz-Revive","url":"http://Geiz-Revive.github.io","root":"/"},"pages":[{"title":"404","date":"2019-06-04T04:39:02.000Z","updated":"2019-06-04T04:39:02.294Z","comments":true,"path":"404/index.html","permalink":"http://Geiz-Revive.github.io/404/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-06-04T04:56:03.000Z","updated":"2019-06-04T10:37:10.205Z","comments":true,"path":"about/index.html","permalink":"http://Geiz-Revive.github.io/about/index.html","excerpt":"","text":""},{"title":"归档","date":"2019-06-03T13:34:48.000Z","updated":"2019-06-03T13:41:35.722Z","comments":true,"path":"archives/index.html","permalink":"http://Geiz-Revive.github.io/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-06-04T04:54:34.000Z","updated":"2019-06-04T04:54:34.464Z","comments":true,"path":"categories/index.html","permalink":"http://Geiz-Revive.github.io/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2019-06-04T04:38:50.000Z","updated":"2019-06-04T04:38:50.824Z","comments":true,"path":"search/index.html","permalink":"http://Geiz-Revive.github.io/search/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-06-03T13:39:13.000Z","updated":"2019-07-18T23:37:03.038Z","comments":true,"path":"tags/index.html","permalink":"http://Geiz-Revive.github.io/tags/index.html","excerpt":"","text":"莫队 $LCT$ 线段树 数学 主席树 线段树合并"}],"posts":[{"title":"杜教筛学习笔记","slug":"杜教筛学习笔记","date":"2019-07-18T08:42:35.000Z","updated":"2019-07-19T03:50:22.101Z","comments":true,"path":"2019/07/18/杜教筛学习笔记/","link":"","permalink":"http://Geiz-Revive.github.io/2019/07/18/杜教筛学习笔记/","excerpt":"","text":"狄利克雷卷积 定义：对于积性函数$f(n)$和$g(n)$，$(f\\ast g)(n)=\\sum\\limits f(d)g(\\dfrac{n}{d})$ 常见完全积性函数： 元函数 $\\epsilon(n)=[n=1]$ 单位函数$id(n)=n$ 常数函数$1(n)=1$ 常见卷积： 1： 因为$\\sum\\limits_{d|n}\\mu(d)=[n=1]=\\epsilon$ 所以两边卷个1得到$\\mu \\ast 1=\\epsilon$ 然后我们可以得出$\\sum\\limits_{i|n}^n\\mu(i)1(\\dfrac{n}{i})=\\sum\\limits_{i=1}^n\\epsilon(i)=1$ 2： 因为$\\sum\\limits_{d|n}\\phi(d)=n=id(n)$ 所以卷个1得到$\\phi\\ast1=id$ 然后可以得到$\\sum\\limits_{i|n}^n \\phi(i)1(\\dfrac{n}{i})=\\sum\\limits_{i=1}^nid(i)=\\dfrac{n\\ast (n+1)}{2}$ 3 : 因为$\\phi\\ast1=id$ 两边卷个$\\mu$得到$\\phi1\\mu=id\\ast\\mu$ $\\phi\\ast\\epsilon=id\\ast\\mu$ $\\phi(n)=\\sum\\limits_{d|n}\\mu(d)\\times\\dfrac{n}{d}$ 两边同除以$n$得$\\dfrac{\\phi(n)}{n}=\\sum\\limits_{d|n}\\dfrac{\\mu(d)}{d}$ 4 : $\\sum\\limits_{i=1}^ni^k\\ast\\phi(i)$ 卷上$id^k$得$\\sum\\limits_{d|n}d^k\\phi(d)*(\\dfrac{n}{d})^k=n^k$ 杜教筛其实就是一个式子： $g(1)S(n)=\\sum\\limits_{i=1}^n(f\\ast g)-\\sum\\limits_{i=2}^ng(i)S(\\dfrac{n}{i})$ 杜教筛用于快速求前缀和，复杂度似乎是$\\Theta(n^{\\frac{2}{3}})$，然而我并不会证明。 有了这个式子，我们就可以利用一个好算的卷积前缀和递归求解一个和式。 由上面的常见卷积1可得：$S(n)=\\sum\\limits_{i=1}^n\\epsilon(i)-\\sum\\limits_{i=2}^nS(\\dfrac{n}{i})=1-\\sum\\limits_{i=2}^nS(\\dfrac{n}{i})$ 后面那个式子显然可以整除分块。 其他的同理。 例题 咕","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://Geiz-Revive.github.io/tags/数学/"}]},{"title":"虚树学习笔记","slug":"虚树学习笔记","date":"2019-07-16T13:36:20.000Z","updated":"2019-07-17T03:42:27.491Z","comments":true,"path":"2019/07/16/虚树学习笔记/","link":"","permalink":"http://Geiz-Revive.github.io/2019/07/16/虚树学习笔记/","excerpt":"","text":"虚树用来解决询问多个关键点，且关键点总数不多的一类问题，记每次询问的关键点个数为$n$，通常$\\sum_{n}\\le 1e5$是用到虚树的题目的共性。当树上部分节点用处不大的时候，我们可以把它们从树上删掉，只保留关键点和它们的$LCA$。虚树的点数级别是$\\Theta(n)$的，因为只包含了$n$个关键点以及它们的$LCA$，所以总点数最多是$2n-1$个。构造虚树： 首先我们需要把$LCA$预处理出来，可以用$ST$表或者树链剖分，顺便处理出树的$dfs$序。 将询问的关键点按照$dfs$序排序，为了方便我们先把根加入数组中，求出相邻两点的$LCA$，加入关键点数组中重新再按照$dfs$序排序，并去重，现在我们已经得到了虚树上所有的点的前序遍历。 如果当前点在栈顶子树中 将栈顶和当前点连边，并将当前点入栈。 如果当前点不在栈顶子树中，说明此时栈顶所在的一段链已经$Dfs$完毕，弹栈，重复执行该过程直到满足情况1。 $\\Large Code:$ 12345678910111213141516171819202122inl void build() &#123; memset(head, 0, sizeof(head)), tot = 0; int tmp = a.size(); for (int i = 0; i &lt; tmp - 1; i++) a.push_back(lca(a[i], a[i + 1])); sort(a.begin(), a.end(), [](int a, int b) -&gt; bool &#123;return dfn[a] &lt; dfn[b]; &#125;); auto it = unique(a.begin(), a.end()); a.erase(it, a.end()); sort(a.begin(), a.end(), [](int a, int b) -&gt; bool &#123;return dfn[a] &lt; dfn[b]; &#125;); rt = st[++top] = a[0]; for (int i = 1; i &lt; a.size(); i++) &#123; int now = a[i]; while (top &gt;= 1) &#123; if (fir[now] &gt;= fir[st[top]] &amp;&amp; fir[now] &lt;= las[st[top]]) &#123; add(st[top], now); break; &#125; top--; &#125; if (st[top] != now) st[++top] = now; &#125; &#125;","categories":[],"tags":[{"name":"虚树","slug":"虚树","permalink":"http://Geiz-Revive.github.io/tags/虚树/"}]},{"title":"洛谷-P3242-接水果","slug":"洛谷-P3242-接水果","date":"2019-07-15T08:07:54.000Z","updated":"2019-07-15T08:08:48.293Z","comments":true,"path":"2019/07/15/洛谷-P3242-接水果/","link":"","permalink":"http://Geiz-Revive.github.io/2019/07/15/洛谷-P3242-接水果/","excerpt":"","text":"$\\Large \\color{rgb(0,255,255)}Describe$ 树上莫队 + 值域分块，复杂度$\\Theta(n\\sqrt n+nlogn)$ 我们把一个盘子看做是两个点，然后当在莫队同时加入这个两个点时，我们就相应的把这个盘子加入值域分块中，删除同理。用一个$vector$维护每个点上带着的盘子。 值域分块的$trick$和这个题一样，查询$\\sqrt n$，加入删除都是$\\Theta(1)$的，和莫队的复杂度摊掉了，然后看到$1e9$的值域很显然是要离散化，然后这题差不多就做完了。 本蒟蒻做的时候$LCA$写错调了好久，希望各位不要犯这种睿智错误，$LCA$用的是$\\Theta(nlogn)/\\Theta(1)$$LCA$ $\\Large Code:$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#pragma region revive#include &lt;set&gt;#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#define inl inline#define re register int#define fa(x) t[x].fa#define son(x, y) t[x].child[y]#define ls(x) t[x].child[0]#define rs(x) t[x].child[1]#define ll long longconst int inf = 0x3f3f3f3f;#define lowbit(x) ((x) &amp; (-x))using namespace std;#ifndef _DEBUG#define getchar() (*(IOB.in.p++))#define putchar(c) (*(IOB.out.p++) = (c))#define io_eof() (IOB.in.p &gt;= IOB.in.pend)struct IOBUF &#123; struct &#123; char buff[1 &lt;&lt; 26], *p, *pend; &#125; in; struct &#123; char buff[1 &lt;&lt; 26], *p; &#125; out; IOBUF() &#123; in.p = in.buff; out.p = out.buff; in.pend = in.buff + fread(in.buff, 1, 1 &lt;&lt; 26, stdin); &#125; ~IOBUF() &#123; fwrite(out.buff, 1, out.p - out.buff, stdout); &#125;&#125; IOB;#endiftemplate &lt;typename IO&gt;inl void write(IO x) &#123; if (x == 0) return (void)putchar('0'); if (x &lt; 0) putchar('-'), x = -x; static char buf[30]; char *p = buf; while (x) &#123; *(p++) = x % 10 + '0'; x /= 10; &#125; while (p &gt; buf) putchar(*(--p));&#125;inl void writestr(const char *s) &#123; while (*s != 0) putchar(*(s++));&#125;template &lt;typename IO&gt;inl void writeln(IO x) &#123; write(x), putchar('\\n'); &#125;template &lt;typename IO&gt;inl void writesp(IO x) &#123; write(x), putchar(' '); &#125;inl int readstr(char *s) &#123; char *begin = s, c = getchar(); while (c &lt; 33 || c &gt; 127) &#123; c = getchar(); &#125; while (c &gt;= 33 &amp;&amp; c &lt;= 127) &#123; *(s++) = c; c = getchar(); &#125; *s = 0; return s - begin;&#125;template &lt;typename IO&gt;inl IO read() &#123; IO x = 0; register bool w = 0; register char c = getchar(); while (c &gt; '9' || c &lt; '0') &#123; if (c == '-') w = 1; c = getchar(); &#125; while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); c = getchar(); &#125; return w ? -x : x;&#125;#pragma endregionint f[100001][20], dep[50001], st[50001], ed[50001], o[100001], euler[100001], head[50001], mp[100001], lg[100001], len, tot, num, a[100001], b[100001], t[100001];vector&lt;int&gt; ve[40001];struct edge &#123; int next, to;&#125; e[100001];inl void adde(int x, int y) &#123; e[++tot] = edge&#123; head[x], y &#125;, head[x] = tot; e[++tot] = edge&#123; head[y], x &#125;, head[y] = tot;&#125;inl void dfs(int x, int fa) &#123; euler[++euler[0]] = x, o[++len] = x, st[x] = euler[0], mp[x] = len, dep[x] = dep[fa] + 1; for (re i = head[x]; i; i = e[i].next) &#123; if (e[i].to != fa) &#123; dfs(e[i].to, x); o[++len] = x; &#125; &#125; euler[++euler[0]] = x, ed[x] = euler[0];&#125;inl int lca(int l, int r) &#123; l = mp[l], r = mp[r]; re x = min(l, r), y = max(l, r), k = lg[y - x + 1]; l = x, r = y; return dep[f[l][k]] &lt; dep[f[r - (1 &lt;&lt; k) + 1][k]] ? f[l][k] : f[r - (1 &lt;&lt; k) + 1][k];&#125;int s[100001], sum[1001], sz[1001], cnt[100001], buc[100001], ans[100001];inl void init() &#123; dfs(1, 0); for (re i = 2; i &lt;= len; i++)lg[i] = lg[i &gt;&gt; 1] + 1; for (re i = 1; i &lt;= len; i++)f[i][0] = o[i]; for (re j = 1; j &lt;= lg[len]; j++) &#123; for (re i = 1; i + (1 &lt;&lt; j) - 1 &lt;= len; i++) &#123; f[i][j] = dep[f[i][j - 1]] &lt; dep[f[i + (1 &lt;&lt; (j - 1))][j - 1]] ? f[i][j - 1] : f[i + (1 &lt;&lt; (j - 1))][j - 1]; &#125; &#125; num = sqrt(euler[0]); for (re i = 1; i &lt;= euler[0]; i++)s[i] = (i - 1) / num + 1, sz[s[i]]++;&#125;bool vis[100001];struct quiz &#123; int l, r, k, lca, id; bool operator&lt;(const quiz &amp;a) &#123; return s[l] == s[a.l] ? s[l] &amp; 1 ? r &lt; a.r : r &gt; a.r : s[l] &lt; s[a.l]; &#125;&#125; q[100001];inl void add(int x) &#123; for (auto i : ve[x])((++buc[i]) == 2) ? (cnt[a[i]]++, sum[s[a[i]]]++) : 0;&#125;inl void del(int x) &#123; for (auto i : ve[x])(buc[i] == 2) ? (cnt[a[i]]--, buc[i]--, sum[s[a[i]]]--) : (buc[i]--);&#125;inl void oper(int x) &#123; (vis[x] ^= 1) ? add(x) : del(x);&#125;signed main() &#123; re n = read&lt;int&gt;(), p = read&lt;int&gt;(), m = read&lt;int&gt;(), x, y, w, f; for (re i = 1; i &lt; n; i++) x = read&lt;int&gt;(), y = read&lt;int&gt;(), adde(x, y); init(); for (re i = 1; i &lt;= p; i++) &#123; x = read&lt;int&gt;(), y = read&lt;int&gt;(), w = read&lt;int&gt;(); ve[x].push_back(i), ve[y].push_back(i), a[i] = b[i] = w; &#125; sort(b + 1, b + 1 + p); re siz = unique(b + 1, b + 1 + p) - b - 1; for (re i = 1; i &lt;= p; i++) &#123; re k = a[i]; t[a[i] = lower_bound(b + 1, b + 1 + siz, a[i]) - b] = k; &#125; for (re i = 1; i &lt;= m; i++) &#123; x = read&lt;int&gt;(), y = read&lt;int&gt;(), w = read&lt;int&gt;(); if (st[x] &gt; st[y]) swap(x, y); f = lca(x, y); if (x != f) q[i] = quiz&#123; ed[x], st[y], w, f, i &#125;; else q[i] = quiz&#123; st[x], st[y], w, 0, i &#125;; &#125; sort(q + 1, q + 1 + m); re l = 1, r = 0, res = 0; for (re i = 1; i &lt;= m; i++) &#123; while (l &lt; q[i].l)oper(euler[l++]); while (l &gt; q[i].l)oper(euler[--l]); while (r &lt; q[i].r)oper(euler[++r]); while (r &gt; q[i].r)oper(euler[r--]); if (q[i].lca) oper(q[i].lca); res = 0; for (re j = 1; j &lt;= s[siz]; j++) &#123; if (res + sum[j] &lt; q[i].k)res += sum[j]; else &#123; for (re l = (j - 1) * num + 1, r = l + sz[j] - 1; l &lt;= r; l++) &#123; if ((res += cnt[l]) &gt;= q[i].k) &#123; ans[q[i].id] = t[l]; goto begin; &#125; &#125; &#125; &#125; begin: if (q[i].lca)oper(q[i].lca); &#125; for (re i = 1; i &lt;= m; i++)writeln(ans[i]);&#125;","categories":[],"tags":[{"name":"莫队","slug":"莫队","permalink":"http://Geiz-Revive.github.io/tags/莫队/"}]},{"title":"CF785E-Anton-and-Permutation","slug":"CF785E-Anton-and-Permutation","date":"2019-06-21T07:43:18.000Z","updated":"2019-06-21T08:04:18.587Z","comments":true,"path":"2019/06/21/CF785E-Anton-and-Permutation/","link":"","permalink":"http://Geiz-Revive.github.io/2019/06/21/CF785E-Anton-and-Permutation/","excerpt":"","text":"$\\Large \\color{Green}{Describe}$ 题意 ：对于一个长度为$n$$(n\\le 200000)$的序列进行$q$$(q \\le 50000)$次操作，每次操作都是交换序列中的某两个数。对于每一个操作，回答当前序列中有多少个逆序对。 本题是一个三维偏序问题，所求即为满足$pos_i&gt;pos_j 且 val_i&lt;val_j$$或$$pos_i&lt;pos_j 且 val_i&gt;val_j$的$(i,j)$​的对数。 我们考虑每次交换操作，可以拆成两个删除和两个插入，先减去贡献，然后在原位置删除，再交换两个值的$pos$，之后在新位置插入，再加上现在的贡献，这样就做完了$……$吗？ 写出来会发现样例都过不了，原因是我们在这样处理时会额外计算一些贡献 当交换后这两个数产生了一对逆序对时，$ans$- - 当交换后这两个数减少了一对逆序对时，$ans$++ 因为当交换后产生了一对逆序对时，加贡献会把这一对加两遍，同理减少了一对时减贡献会减两遍。 然后就是上树状数组套动态开点权值线段树，时空复杂度均是$\\Theta(nlog^2_n)$ $\\Large Code:$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#pragma region revive#include &lt;set&gt;#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#define inl inline#define re register int#define fa(x) t[x].fa#define son(x,y) t[x].child[y]#define ls(x) t[x].child[0]#define rs(x) t[x].child[1]#define ll long longconst int inf = 0x3f3f3f3f;#define lowbit(x) ((x) &amp; (-x))using namespace std;#ifndef _DEBUG#define getchar() (*(IOB.in.p++))#define putchar(c) (*(IOB.out.p++)=(c))#define io_eof() (IOB.in.p&gt;=IOB.in.pend)struct IOBUF &#123; struct &#123; char buff[1 &lt;&lt; 26], *p, *pend; &#125;in; struct &#123; char buff[1 &lt;&lt; 26], *p; &#125;out; IOBUF() &#123; in.p = in.buff; out.p = out.buff; in.pend = in.buff + fread(in.buff, 1, 1 &lt;&lt; 26, stdin); &#125;~IOBUF() &#123; fwrite(out.buff, 1, out.p - out.buff, stdout); &#125; &#125;IOB;#endiftemplate&lt;typename IO&gt;inl void write(IO x) &#123; if (x == 0) return (void)putchar('0'); if (x &lt; 0)putchar('-'), x = -x; static char buf[30]; char* p = buf; while (x) &#123; *(p++) = x % 10 + '0'; x /= 10; &#125; while (p &gt; buf)putchar(*(--p));&#125;inl void writestr(const char *s) &#123; while (*s != 0)putchar(*(s++)); &#125;template&lt;typename IO&gt;inl void writeln(IO x) &#123; write(x), putchar('\\n'); &#125;template&lt;typename IO&gt;inl void writesp(IO x) &#123; write(x), putchar(' '); &#125;inl int readstr(char *s) &#123; char *begin = s, c = getchar(); while (c &lt; 33 || c&gt;127) &#123; c = getchar(); &#125; while (c &gt;= 33 &amp;&amp; c &lt;= 127) &#123; *(s++) = c; c = getchar(); &#125; *s = 0; return s - begin;&#125;template&lt;typename IO&gt;inl IO read() &#123; IO x = 0; register bool w = 0; register char c = getchar(); while (c &gt; '9' || c &lt; '0') &#123; if (c == '-') w = 1; c = getchar(); &#125; while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); c = getchar(); &#125; return w ? -x : x;&#125;#pragma endregion#undef ls#undef rs#define ls(x) t[x].l#define rs(x) t[x].rint root[1000001], cnt, pos[1000001], tmpl[51], tmpr[51], cntl, cntr, n;struct node &#123; int w, l, r;&#125;t[20000001];inl void maintain(int x) &#123; t[x].w = t[ls(x)].w + t[rs(x)].w;&#125;inl void change(int &amp;k, int l, int r, int p, int w) &#123; if (!k)k = ++cnt; if (l == r)return (void)(t[k].w += w); re mid = l + r &gt;&gt; 1; if (p &lt;= mid)change(ls(k), l, mid, p, w); else change(rs(k), mid + 1, r, p, w); maintain(k);&#125;inl int query(int l, int r, int x, bool op) &#123; cntl = cntr = 0; for (re i = l - 1; i; i -= lowbit(i)) tmpl[++cntl] = root[i]; for (re i = r; i; i -= lowbit(i))tmpr[++cntr] = root[i]; l = 1, r = n; re mid, ans = 0; while (l != r) &#123; mid = l + r &gt;&gt; 1; if (x &lt;= mid) &#123; if (op) &#123; for (re i = 1; i &lt;= cntl; i++)ans -= t[rs(tmpl[i])].w; for (re i = 1; i &lt;= cntr; i++)ans += t[rs(tmpr[i])].w; &#125; for (re i = 1; i &lt;= cntl; i++)tmpl[i] = ls(tmpl[i]); for (re i = 1; i &lt;= cntr; i++)tmpr[i] = ls(tmpr[i]); r = mid; &#125; else &#123; if (!op) &#123; for (re i = 1; i &lt;= cntl; i++)ans -= t[ls(tmpl[i])].w; for (re i = 1; i &lt;= cntr; i++)ans += t[ls(tmpr[i])].w; &#125; for (re i = 1; i &lt;= cntl; i++)tmpl[i] = rs(tmpl[i]); for (re i = 1; i &lt;= cntr; i++)tmpr[i] = rs(tmpr[i]); l = mid + 1; &#125; &#125; return ans;&#125;signed main() &#123; n = read&lt;int&gt;(); re m = read&lt;int&gt;(), x, y; ll ans = 0; for (re i = 1; i &lt;= n; i++) &#123; pos[i] = i; for (re j = i; j &lt;= n; j += lowbit(j)) change(root[j], 1, n, i, 1); &#125; while (m--) &#123; x = read&lt;int&gt;(), y = read&lt;int&gt;(); if (x == y) &#123; writeln(ans); continue; &#125; ans -= query(1, pos[x] - 1, x, 1) + query(pos[x] + 1, n, x, 0); ans -= query(1, pos[y] - 1, y, 1) + query(pos[y] + 1, n, y, 0); for (re i = pos[x]; i &lt;= n; i += lowbit(i))change(root[i], 1, n, x, -1); for (re i = pos[y]; i &lt;= n; i += lowbit(i))change(root[i], 1, n, y, -1); swap(pos[x], pos[y]); for (re i = pos[x]; i &lt;= n; i += lowbit(i))change(root[i], 1, n, x, 1); for (re i = pos[y]; i &lt;= n; i += lowbit(i))change(root[i], 1, n, y, 1); ans += query(1, pos[x] - 1, x, 1) + query(pos[x] + 1, n, x, 0); ans += query(1, pos[y] - 1, y, 1) + query(pos[y] + 1, n, y, 0); ans -= (pos[x] &gt; pos[y] &amp;&amp; x &lt; y) || (pos[x] &lt; pos[y] &amp;&amp; x &gt; y); ans += (pos[x] &gt; pos[y] &amp;&amp; x &gt; y) || (pos[x] &lt; pos[y] &amp;&amp; x &lt; y); writeln(ans); &#125;&#125;","categories":[],"tags":[{"name":"主席树","slug":"主席树","permalink":"http://Geiz-Revive.github.io/tags/主席树/"}]},{"title":"CF474F-Ant-Colony","slug":"CF474F-Ant-Colony","date":"2019-06-20T08:38:21.000Z","updated":"2019-06-20T08:51:16.431Z","comments":true,"path":"2019/06/20/CF474F-Ant-Colony/","link":"","permalink":"http://Geiz-Revive.github.io/2019/06/20/CF474F-Ant-Colony/","excerpt":"","text":"$\\Large\\color{pink}{Describe}$ 这题的题意是要求出不能整除区间内所有数的个数，正难则反一下就变成了区间长度减去能整除区间内所有数的个数，显然这个数就是区间的$gcd$（窝太菜了一开始还以为可以是$gcd$的约数，后来发现是窝傻了），然后就可以发现这个$sum$跟$gcd$是具有可加性的，之后就大力上线段树就完事了。 目前是本题最优解，欢迎超越。 维护部分的代码： 123456node operator +(node a, node b) &#123; node c; c.gcd = gcd(a.gcd, b.gcd); c.sum = (a.gcd == c.gcd)*a.sum + (b.gcd == c.gcd)*b.sum; return c;&#125; $\\large Code:$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#pragma region revive#include &lt;set&gt;#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#define inl inline#define re register int#define fa(x) t[x].fa#define son(x,y) t[x].child[y]#define ls(x) t[x].child[0]#define rs(x) t[x].child[1]#define ll long longconst int inf = 0x3f3f3f3f;#define lowbit(x) ((x) &amp; (-x))using namespace std;#ifndef _DEBUG#define getchar() (*(IOB.in.p++))#define putchar(c) (*(IOB.out.p++)=(c))#define io_eof() (IOB.in.p&gt;=IOB.in.pend)struct IOBUF &#123; struct &#123; char buff[1 &lt;&lt; 26], *p, *pend; &#125;in; struct &#123; char buff[1 &lt;&lt; 26], *p; &#125;out; IOBUF() &#123; in.p = in.buff; out.p = out.buff; in.pend = in.buff + fread(in.buff, 1, 1 &lt;&lt; 26, stdin); &#125;~IOBUF() &#123; fwrite(out.buff, 1, out.p - out.buff, stdout); &#125; &#125;IOB;#endiftemplate&lt;typename IO&gt;inl void write(IO x) &#123; if (x == 0) return (void)putchar('0'); if (x &lt; 0)putchar('-'), x = -x; static char buf[30]; char* p = buf; while (x) &#123; *(p++) = x % 10 + '0'; x /= 10; &#125; while (p &gt; buf)putchar(*(--p));&#125;inl void writestr(const char *s) &#123; while (*s != 0)putchar(*(s++)); &#125;template&lt;typename IO&gt;inl void writeln(IO x) &#123; write(x), putchar('\\n'); &#125;template&lt;typename IO&gt;inl void writesp(IO x) &#123; write(x), putchar(' '); &#125;inl int readstr(char *s) &#123; char *begin = s, c = getchar(); while (c &lt; 33 || c&gt;127) &#123; c = getchar(); &#125; while (c &gt;= 33 &amp;&amp; c &lt;= 127) &#123; *(s++) = c; c = getchar(); &#125; *s = 0; return s - begin;&#125;template&lt;typename IO&gt;inl IO read() &#123; IO x = 0; register bool w = 0; register char c = getchar(); while (c &gt; '9' || c &lt; '0') &#123; if (c == '-') w = 1; c = getchar(); &#125; while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); c = getchar(); &#125; return w ? -x : x;&#125;#pragma endregioninl int gcd(int x, int y) &#123; if (x &lt; y)swap(x, y); return y ? gcd(y, x%y) : x; &#125;struct node &#123; int gcd, sum;&#125;t[500001];node operator +(node a, node b) &#123; node c; c.gcd = gcd(a.gcd, b.gcd); c.sum = (a.gcd == c.gcd)*a.sum + (b.gcd == c.gcd)*b.sum; return c;&#125;int a[100001];inl void maintain(int x) &#123; t[x] = t[x &lt;&lt; 1] + t[x &lt;&lt; 1 | 1]; &#125;inl void build(int k, int l, int r) &#123; if (l == r) &#123; return (void)(t[k].gcd = a[l], t[k].sum = 1); &#125; re mid = l + r &gt;&gt; 1; build(k &lt;&lt; 1, l, mid), build(k &lt;&lt; 1 | 1, mid + 1, r); maintain(k);&#125;inl node query(int k, int l, int r, int x, int y) &#123; if (l &gt;= x &amp;&amp; r &lt;= y)return t[k]; re mid = l + r &gt;&gt; 1; node ans = &#123; 0,0 &#125;; if (x &lt;= mid)ans = ans + query(k &lt;&lt; 1, l, mid, x, y); if (y &gt; mid)ans = ans + query(k &lt;&lt; 1 | 1, mid + 1, r, x, y); return ans;&#125;signed main() &#123; re n = read&lt;int&gt;(), m; for (re i = 1; i &lt;= n; i++)a[i] = read&lt;int&gt;(); build(1, 1, n); m = read&lt;int&gt;(); while (m--) &#123; re x = read&lt;int&gt;(), y = read&lt;int&gt;(); writeln(y - x + 1 - query(1, 1, n, x, y).sum); &#125;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://Geiz-Revive.github.io/tags/线段树/"}]},{"title":"CF827D-BestEdgeWeight","slug":"CF827D-BestEdgeWeight","date":"2019-06-20T07:39:15.000Z","updated":"2019-06-20T07:41:05.036Z","comments":true,"path":"2019/06/20/CF827D-BestEdgeWeight/","link":"","permalink":"http://Geiz-Revive.github.io/2019/06/20/CF827D-BestEdgeWeight/","excerpt":"","text":"$\\Large\\color{orange}{Describe}$ 题意是要求出一条边的边权为多大时，能出现在所有的最小生成树中，因此我们先随便造一棵最小生成树，进行分类讨论。 对于非树边，它的答案是它链接的这两个点在最小生成树上的链的最大值再-1，这样它才能替换掉树边。 对于树边，它的答案是能够让它所链接的两个点联通的非树边的最小值再减一，否则它会被替换掉。 之后可以发现，我们需要的只不过是一个能查询链上最大值、链上取最小值的一个数据结构，因此树剖$\\Theta(nlog^2_n)$，LCT $\\Theta(nlog_n)$ $\\large Code:$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#pragma region revive#include &lt;set&gt;#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#define inl inline#define re register int#define fa(x) t[x].fa#define son(x,y) t[x].child[y]#define ls(x) t[x].child[0]#define rs(x) t[x].child[1]#define ll long longconst int inf = 0x3f3f3f3f;#define lowbit(x) ((x) &amp; (-x))using namespace std;#ifndef _DEBUG#define getchar() (*(IOB.in.p++))#define putchar(c) (*(IOB.out.p++)=(c))#define io_eof() (IOB.in.p&gt;=IOB.in.pend)struct IOBUF &#123; struct &#123; char buff[1 &lt;&lt; 26], *p, *pend; &#125;in; struct &#123; char buff[1 &lt;&lt; 26], *p; &#125;out; IOBUF() &#123; in.p = in.buff; out.p = out.buff; in.pend = in.buff + fread(in.buff, 1, 1 &lt;&lt; 26, stdin); &#125;~IOBUF() &#123; fwrite(out.buff, 1, out.p - out.buff, stdout); &#125; &#125;IOB;#endiftemplate&lt;typename IO&gt;inl void write(IO x) &#123; if (x == 0) return (void)putchar('0'); if (x &lt; 0)putchar('-'), x = -x; static char buf[30]; char* p = buf; while (x) &#123; *(p++) = x % 10 + '0'; x /= 10; &#125; while (p &gt; buf)putchar(*(--p));&#125;inl void writestr(const char *s) &#123; while (*s != 0)putchar(*(s++)); &#125;template&lt;typename IO&gt;inl void writeln(IO x) &#123; write(x), putchar('\\n'); &#125;template&lt;typename IO&gt;inl void writesp(IO x) &#123; write(x), putchar(' '); &#125;inl int readstr(char *s) &#123; char *begin = s, c = getchar(); while (c &lt; 33 || c&gt;127) &#123; c = getchar(); &#125; while (c &gt;= 33 &amp;&amp; c &lt;= 127) &#123; *(s++) = c; c = getchar(); &#125; *s = 0; return s - begin;&#125;template&lt;typename IO&gt;inl IO read() &#123; IO x = 0; register bool w = 0; register char c = getchar(); while (c &gt; '9' || c &lt; '0') &#123; if (c == '-') w = 1; c = getchar(); &#125; while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); c = getchar(); &#125; return w ? -x : x;&#125;#pragma endregionint fa[1000001], ans[1000001];bool vis[1000001];struct node &#123; int child[2], fa, w, max, tag; bool filp;&#125;t[1000001];inl void maintain(int x) &#123; t[x].max = max(&#123; t[ls(x)].max, t[rs(x)].max, t[x].w &#125;);&#125;inl bool poi(int x) &#123; return rs(fa(x)) == x; &#125;inl bool nroot(int x) &#123; return ls(fa(x)) == x || rs(fa(x)) == x; &#125;inl void reverse(int x) &#123; swap(ls(x), rs(x)), t[x].filp ^= 1; &#125;inl void change(int x, int w) &#123; ans[x] = min(ans[x], w), t[x].tag = min(t[x].tag, w); &#125;inl void rotate(int x) &#123; re f = fa(x), gf = fa(f), fs = poi(x), gfs = poi(f), s = t[x].child[fs ^ 1]; if (nroot(f))t[gf].child[gfs] = x; t[x].child[fs ^ 1] = f, t[f].child[fs] = s; if (s)fa(s) = f; fa(f) = x, fa(x) = gf, maintain(f);&#125;inl void pushdown(int x) &#123; if (t[x].filp) &#123; if (ls(x))reverse(ls(x)); if (rs(x))reverse(rs(x)); t[x].filp = 0; &#125; if (t[x].tag != inf) &#123; if (ls(x))change(ls(x), t[x].tag); if (rs(x))change(rs(x), t[x].tag); t[x].tag = inf; &#125;&#125;inl void push(int x) &#123; if (nroot(x))push(fa(x)); pushdown(x);&#125;inl void splay(int x) &#123; push(x); while (nroot(x)) &#123; if (nroot(fa(x)))poi(x) == poi(fa(x)) ? rotate(fa(x)) : rotate(x); rotate(x); &#125; maintain(x);&#125;inl void access(int x) &#123; for (re i = 0; x; x = fa(i = x)) splay(x), rs(x) = i, maintain(x);&#125;inl void makeroot(int x) &#123; access(x), splay(x), reverse(x);&#125;inl void split(int x, int y) &#123; makeroot(y), access(x), splay(x);&#125;inl void link(int x, int y) &#123; split(x, y), fa(y) = x;&#125;struct edge &#123; int u, v, w, id; bool operator &lt;(const edge &amp;fff)const &#123; return w &lt; fff.w; &#125;&#125;e[1000001];inl int find(int x) &#123; return fa[x] ? fa[x] = find(fa[x]) : x; &#125;signed main() &#123; re n = read&lt;int&gt;(), m = read&lt;int&gt;(), u, v, w = n + m, now; for (re i = 1; i &lt;= w; i++)t[i].tag = ans[i] = inf; for (re i = 1; i &lt;= m; i++) u = read&lt;int&gt;(), v = read&lt;int&gt;(), w = read&lt;int&gt;(), e[i] = edge&#123; u,v,w &#125;, e[i].id = i; sort(e + 1, e + 1 + m); for (re i = 1; i &lt;= m; i++) &#123; u = e[i].u, v = e[i].v, w = e[i].w, now = e[i].id + n; if (find(u) != find(v)) &#123; fa[find(v)] = u; t[now].w = t[now].max = w; link(u, now), link(v, now), vis[now] = 1; &#125; else &#123; split(u, v); ans[now] = t[u].max - 1; change(u, w); &#125; &#125; for (re i = n + 1, k = n + m; i &lt;= k; i++) &#123; if (vis[i]) &#123; access(i), splay(i), writesp(ans[i] == inf ? -1 : ans[i] - 1); &#125; else &#123; writesp(ans[i]); &#125; &#125;&#125;","categories":[],"tags":[{"name":"LCT","slug":"LCT","permalink":"http://Geiz-Revive.github.io/tags/LCT/"}]},{"title":"洛谷-P4513-小白逛公园","slug":"洛谷-P4513-小白逛公园","date":"2019-06-19T09:26:41.000Z","updated":"2019-06-19T09:28:09.646Z","comments":true,"path":"2019/06/19/洛谷-P4513-小白逛公园/","link":"","permalink":"http://Geiz-Revive.github.io/2019/06/19/洛谷-P4513-小白逛公园/","excerpt":"","text":"$\\Large\\color{violet}{Describe}$ 颓完文化课回来做水题能愉悦身心 题意就是单点修改，区间最大子段和，硬上线段树即可，维护是经典方法，如果换成区间修改也是可以做的。有兴趣可以去做一做$GSS$系列的题，最大子段和是个经典模型，尽量要掌握。 12345678node operator +(const node &amp;a, const node &amp;b) &#123; node c; c.tot = a.tot + b.tot; c.lsum = max(a.lsum, b.lsum + a.tot); c.rsum = max(b.rsum, a.rsum + b.tot); c.sum = max(&#123; a.sum,b.sum,a.rsum + b.lsum &#125;); return c;&#125; 其中$tot$代表原数列中的值的和，$sum$是最大子段和，$lsum$是最大前缀和，$rsum$是最大后缀和，维护想一想应该就很显然了。 $\\large Code:$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#pragma region revive#include &lt;set&gt;#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#define inl inline#define re register int#define fa(x) t[x].fa#define son(x,y) t[x].child[y]#define ls(x) t[x].child[0]#define rs(x) t[x].child[1]#define ll long longconst int inf = 0x3f3f3f3f;#define lowbit(x) ((x) &amp; (-x))using namespace std;#ifndef _DEBUG#define getchar() (*(IOB.in.p++))#define putchar(c) (*(IOB.out.p++)=(c))#define io_eof() (IOB.in.p&gt;=IOB.in.pend)struct IOBUF &#123; struct &#123; char buff[1 &lt;&lt; 26], *p, *pend; &#125;in; struct &#123; char buff[1 &lt;&lt; 26], *p; &#125;out; IOBUF() &#123; in.p = in.buff; out.p = out.buff; in.pend = in.buff + fread(in.buff, 1, 1 &lt;&lt; 26, stdin); &#125;~IOBUF() &#123; fwrite(out.buff, 1, out.p - out.buff, stdout); &#125; &#125;IOB;#endiftemplate&lt;typename IO&gt;inl void write(IO x) &#123; if (x == 0) return (void)putchar('0'); if (x &lt; 0)putchar('-'), x = -x; static char buf[30]; char* p = buf; while (x) &#123; *(p++) = x % 10 + '0'; x /= 10; &#125; while (p &gt; buf)putchar(*(--p));&#125;inl void writestr(const char *s) &#123; while (*s != 0)putchar(*(s++)); &#125;template&lt;typename IO&gt;inl void writeln(IO x) &#123; write(x), putchar('\\n'); &#125;template&lt;typename IO&gt;inl void writesp(IO x) &#123; write(x), putchar(' '); &#125;inl int readstr(char *s) &#123; char *begin = s, c = getchar(); while (c &lt; 33 || c&gt;127) &#123; c = getchar(); &#125; while (c &gt;= 33 &amp;&amp; c &lt;= 127) &#123; *(s++) = c; c = getchar(); &#125; *s = 0; return s - begin;&#125;template&lt;typename IO&gt;inl IO read() &#123; IO x = 0; register bool w = 0; register char c = getchar(); while (c &gt; '9' || c &lt; '0') &#123; if (c == '-') w = 1; c = getchar(); &#125; while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); c = getchar(); &#125; return w ? -x : x;&#125;#pragma endregion#undef ls#undef rs#define ls(x) ((x)&lt;&lt;1)#define rs(x) (ls(x)|1)struct node &#123; int lsum, rsum, sum, tot;&#125;t[10000001];node operator +(const node &amp;a, const node &amp;b) &#123; node c; c.tot = a.tot + b.tot; c.lsum = max(a.lsum, b.lsum + a.tot); c.rsum = max(b.rsum, a.rsum + b.tot); c.sum = max(&#123; a.sum,b.sum,a.rsum + b.lsum &#125;); return c;&#125;int a[1000001];inl void maintain(int x) &#123; t[x] = t[ls(x)] + t[rs(x)];&#125;inl void change(int k, int l, int r, int p, int w) &#123; if (l == r) return (void)(t[k].tot = t[k].sum = t[k].lsum = t[k].rsum = w); re mid = l + r &gt;&gt; 1; if (p &lt;= mid)change(ls(k), l, mid, p, w); else change(rs(k), mid + 1, r, p, w); maintain(k);&#125;inl void build(int k, int l, int r) &#123; if (l == r) return (void)(t[k].tot = t[k].sum = t[k].lsum = t[k].rsum = a[l]); re mid = l + r &gt;&gt; 1; build(ls(k), l, mid), build(rs(k), mid + 1, r); maintain(k);&#125;inl node query(int k, int l, int r, int x, int y) &#123; if (l &gt;= x &amp;&amp; r &lt;= y)return t[k]; re mid = l + r &gt;&gt; 1; node ans = &#123; 0,0,0,0 &#125;; if (x &lt;= mid) &#123; ans = query(ls(k), l, mid, x, y); if (y &gt; mid)ans = ans + query(rs(k), mid + 1, r, x, y); &#125; else if (y &gt; mid)ans = query(rs(k), mid + 1, r, x, y); return ans;&#125;signed main() &#123; re n = read&lt;int&gt;(), m = read&lt;int&gt;(), op, x, y; for (re i = 1; i &lt;= n; i++)a[i] = read&lt;int&gt;(); build(1, 1, n); while (m--) &#123; op = read&lt;int&gt;(), x = read&lt;int&gt;(), y = read&lt;int&gt;(); if (op == 1) &#123; if (x &gt; y)swap(x, y); writeln(query(1, 1, n, x, y).sum); &#125; else change(1, 1, n, x, y); &#125;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://Geiz-Revive.github.io/tags/线段树/"}]},{"title":"洛谷-P4374-Disruption","slug":"洛谷-P4374-Disruption","date":"2019-06-16T08:57:51.000Z","updated":"2019-06-16T09:10:28.939Z","comments":true,"path":"2019/06/16/洛谷-P4374-Disruption/","link":"","permalink":"http://Geiz-Revive.github.io/2019/06/16/洛谷-P4374-Disruption/","excerpt":"","text":"$\\large\\color{blue} {Describe}$ 蒟蒻回去颓了十天文化课以后回来的第一题。 分析题意可知，这题可以抽象成给链上的每条边赋值，每条边的权值为这个赋的值和原有值的最小值，然后就是板子了，树剖$log^2$，$LCT$ $log$，这里选择用$LCT$，因为要边转点所以常数还是挺大的。 还有就是注意初始化和要判断无解情况，初始化所有权值和标记为$inf$，统计答案时如果一条边的权为$inf$就输出$-1$ $\\large{Code}$： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#pragma region revive#include &lt;set&gt;#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#define inl inline#define re register int#define fa(x) t[x].fa#define son(x,y) t[x].child[y]#define ls(x) t[x].child[0]#define rs(x) t[x].child[1]#define ll long longconst int inf = 0x3f3f3f3f;#define lowbit(x) ((x) &amp; (-x))using namespace std;#ifndef _DEBUG#define getchar() (*(IOB.in.p++))#define putchar(c) (*(IOB.out.p++)=(c))#define io_eof() (IOB.in.p&gt;=IOB.in.pend)struct IOBUF &#123; struct &#123; char buff[1 &lt;&lt; 26], *p, *pend; &#125;in; struct &#123; char buff[1 &lt;&lt; 26], *p; &#125;out; IOBUF() &#123; in.p = in.buff; out.p = out.buff; in.pend = in.buff + fread(in.buff, 1, 1 &lt;&lt; 26, stdin); &#125;~IOBUF() &#123; fwrite(out.buff, 1, out.p - out.buff, stdout); &#125; &#125;IOB;#endiftemplate&lt;typename IO&gt;inl void write(IO x) &#123; if (x == 0) return (void)putchar('0'); if (x &lt; 0)putchar('-'), x = -x; static char buf[30]; char* p = buf; while (x) &#123; *(p++) = x % 10 + '0'; x /= 10; &#125; while (p &gt; buf)putchar(*(--p));&#125;inl void writestr(const char *s) &#123; while (*s != 0)putchar(*(s++)); &#125;template&lt;typename IO&gt;inl void writeln(IO x) &#123; write(x), putchar('\\n'); &#125;template&lt;typename IO&gt;inl void writesp(IO x) &#123; write(x), putchar(' '); &#125;inl int readstr(char *s) &#123; char *begin = s, c = getchar(); while (c &lt; 33 || c&gt;127) &#123; c = getchar(); &#125; while (c &gt;= 33 &amp;&amp; c &lt;= 127) &#123; *(s++) = c; c = getchar(); &#125; *s = 0; return s - begin;&#125;template&lt;typename IO&gt;inl IO read() &#123; IO x = 0; register bool w = 0; register char c = getchar(); while (c &gt; '9' || c &lt; '0') &#123; if (c == '-') w = 1; c = getchar(); &#125; while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); c = getchar(); &#125; return w ? -x : x;&#125;#pragma endregionstruct node &#123; int fa, child[2], w, tag; bool filp;&#125;t[1000001];inl void change(int x, int w) &#123; t[x].w = min(t[x].w, w), t[x].tag = min(t[x].tag, w);&#125;inl void reverse(int x) &#123; swap(ls(x), rs(x)), t[x].filp ^= 1;&#125;inl void pushdown(int x) &#123; if (t[x].filp) &#123; if (ls(x))reverse(ls(x)); if (rs(x))reverse(rs(x)); t[x].filp = 0; &#125; if (t[x].tag != inf) &#123; if (ls(x))change(ls(x), t[x].tag); if (rs(x))change(rs(x), t[x].tag); t[x].tag = inf; &#125;&#125;inl bool nroot(int x) &#123; return ls(fa(x)) == x || rs(fa(x)) == x; &#125;inl bool poi(int x) &#123; return rs(fa(x)) == x; &#125;inl void push(int x) &#123; if (nroot(x))push(fa(x)); pushdown(x);&#125;inl void rotate(int x) &#123; re f = fa(x), gf = fa(f), fs = poi(x), gfs = poi(f), s = t[x].child[fs ^ 1]; if (nroot(f))t[gf].child[gfs] = x; t[f].child[fs] = s, t[x].child[fs ^ 1] = f; if (s)fa(s) = f; fa(x) = gf, fa(f) = x;&#125;inl void splay(int x) &#123; push(x); while (nroot(x)) &#123; if (nroot(fa(x)))poi(x) == poi(fa(x)) ? rotate(fa(x)) : rotate(x); rotate(x); &#125;&#125;inl void access(int x) &#123; for (re i = 0; x; x = fa(i = x)) splay(x), rs(x) = i; &#125;inl void makeroot(int x) &#123; access(x), splay(x), reverse(x); &#125;inl void split(int x, int y) &#123; makeroot(y), access(x), splay(x); &#125;inl void link(int x, int y) &#123; split(x, y), fa(y) = x; &#125;struct edge &#123; int u, v;&#125;e[1000001];signed main() &#123; re n = read&lt;int&gt;(), m = read&lt;int&gt;(), x, y, w; for (re i = 0; i &lt;= n; i++)t[i].w = t[i + n].w = inf; for (re i = 1; i &lt; n; i++)x = read&lt;int&gt;(), y = read&lt;int&gt;(), e[i] = edge&#123; x,y &#125;, link(x, i + n), link(y, i + n); while (m--) &#123; x = read&lt;int&gt;(), y = read&lt;int&gt;(), w = read&lt;int&gt;(); split(x, y), change(x, w); &#125; for (re i = 1; i &lt; n; i++)split(e[i].u, e[i].v), writeln(t[i + n].w == inf ? -1 : t[i + n].w);&#125;","categories":[],"tags":[{"name":"LCT","slug":"LCT","permalink":"http://Geiz-Revive.github.io/tags/LCT/"}]},{"title":"洛谷 P4556 [Vani有约会] 雨天的尾巴","slug":"洛谷-P4556-Vani有约会-雨天的尾巴","date":"2019-06-04T10:36:03.000Z","updated":"2019-06-04T13:52:42.119Z","comments":true,"path":"2019/06/04/洛谷-P4556-Vani有约会-雨天的尾巴/","link":"","permalink":"http://Geiz-Revive.github.io/2019/06/04/洛谷-P4556-Vani有约会-雨天的尾巴/","excerpt":"","text":"线段树合并入门题（然而还是因为$sb$错误交了好几次），考虑每个节点建一棵动态开点的线段树，每次进行树上差分，这里给出一些主要代码片段： 更新： 123456inl void maintain(int x) &#123; if (t[ls(x)].w &gt;= t[rs(x)].w) &#123; t[x].w = t[ls(x)].w, t[x].c = t[ls(x)].c; &#125; else t[x].w = t[rs(x)].w, t[x].c = t[rs(x)].c;//c表示颜色，w表示权值&#125; 合并： 123456789101112inl int merge(int p, int q, int l, int r) &#123; if (!p || !q)return p + q; if (l == r) &#123; t[p].w += t[q].w, t[p].c = t[q].c; return p; &#125; re mid = l + r &gt;&gt; 1; ls(p) = merge(ls(p), ls(q), l, mid); rs(p) = merge(rs(p), rs(q), mid + 1, r); maintain(p); return p;&#125; 还有一个比较迷的点就是当我没有离散化时 12345678910111213141516inl void maintain(int x) &#123; if (t[ls(x)].w &gt;= t[rs(x)].w) &#123; t[x].w = t[ls(x)].w, t[x].c = t[ls(x)].c; &#125; else t[x].w = t[rs(x)].w, t[x].c = t[rs(x)].c; if(!t[x].w)t[x].c = 0;&#125;inl void solve(int x) &#123; for (re i = head[x]; i; i = e[i].next) &#123; if (e[i].to != fa[x]) &#123; solve(e[i].to); root[x] = merge(root[x], root[e[i].to], 1, s); &#125; &#125; ans[x] = t[root[x]].w;&#125; 这样写是对的 但是如果离散化以后，这样就只有95$pts$??? 于是乎经多次测试，离散化以后应该这样写： 123456789101112131415inl void maintain(int x) &#123; if (t[ls(x)].w &gt;= t[rs(x)].w) &#123; t[x].w = t[ls(x)].w, t[x].c = t[ls(x)].c; &#125; else t[x].w = t[rs(x)].w, t[x].c = t[rs(x)].c;&#125;inl void solve(int x) &#123; for (re i = head[x]; i; i = e[i].next) &#123; if (e[i].to != fa[x]) &#123; solve(e[i].to); root[x] = merge(root[x], root[e[i].to], 1, s); &#125; &#125; ans[x] = t[root[x]].w ? mp[t[root[x]].c] : 0;&#125; 我认为这两种写法应该是完全没有差别的，但是结果并不一样$emmm$。 全部代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#pragma region revive#include &lt;set&gt;#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#define inl inline#define re register int#define fa(x) t[x].fa#define son(x,y) t[x].child[y]#define ls(x) t[x].child[0]#define rs(x) t[x].child[1]#define ll long longconst int inf = 0x3f3f3f3f;#define lowbit(x) ((x) &amp; (-x))using namespace std;#ifndef _DEBUG#define getchar() (*(IOB.in.p++))#define putchar(c) (*(IOB.out.p++)=(c))#define io_eof() (IOB.in.p&gt;=IOB.in.pend)struct IOBUF &#123; struct &#123; char buff[1 &lt;&lt; 26], *p, *pend; &#125;in; struct &#123; char buff[1 &lt;&lt; 26], *p; &#125;out; IOBUF() &#123; in.p = in.buff; out.p = out.buff; in.pend = in.buff + fread(in.buff, 1, 1 &lt;&lt; 26, stdin); &#125;~IOBUF() &#123; fwrite(out.buff, 1, out.p - out.buff, stdout); &#125; &#125;IOB;#endiftemplate&lt;typename IO&gt;inl void write(IO x) &#123; if (x == 0) return (void)putchar('0'); if (x &lt; 0)putchar('-'), x = -x; static char buf[30]; char* p = buf; while (x) &#123; *(p++) = x % 10 + '0'; x /= 10; &#125; while (p &gt; buf)putchar(*(--p));&#125;inl void writestr(const char *s) &#123; while (*s != 0)putchar(*(s++)); &#125;template&lt;typename IO&gt;inl void writeln(IO x) &#123; write(x), putchar('\\n'); &#125;template&lt;typename IO&gt;inl void writesp(IO x) &#123; write(x), putchar(' '); &#125;inl int readstr(char *s) &#123; char *begin = s, c = getchar(); while (c &lt; 33 || c&gt;127) &#123; c = getchar(); &#125; while (c &gt;= 33 &amp;&amp; c &lt;= 127) &#123; *(s++) = c; c = getchar(); &#125; *s = 0; return s - begin;&#125;template&lt;typename IO&gt;inl IO read() &#123; IO x = 0; register bool w = 0; register char c = getchar(); while (c &gt; '9' || c &lt; '0') &#123; if (c == '-') w = 1; c = getchar(); &#125; while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); c = getchar(); &#125; return w ? -x : x;&#125;#pragma endregion#undef ls#undef rs#define ls(x) t[x].l#define rs(x) t[x].rint cnt, s;struct node &#123; int l, r, w, c;&#125;t[10000001];inl void maintain(int x) &#123; if (t[ls(x)].w &gt;= t[rs(x)].w) &#123; t[x].w = t[ls(x)].w, t[x].c = t[ls(x)].c; &#125; else t[x].w = t[rs(x)].w, t[x].c = t[rs(x)].c;&#125;inl void add(int &amp;k, int l, int r, int p, int w) &#123; if (!k)k = ++cnt; if (l == r) &#123; t[k].w += w, t[k].c = p; return; &#125; re mid = l + r &gt;&gt; 1; if (p &lt;= mid)add(ls(k), l, mid, p, w); else add(rs(k), mid + 1, r, p, w); maintain(k);&#125;inl int merge(int p, int q, int l, int r) &#123; if (!p || !q)return p + q; if (l == r) &#123; t[p].w += t[q].w, t[p].c = t[q].c; return p; &#125; re mid = l + r &gt;&gt; 1; ls(p) = merge(ls(p), ls(q), l, mid); rs(p) = merge(rs(p), rs(q), mid + 1, r); maintain(p); return p;&#125;int head[1000001], tot, top[1000001], dep[1000001], h[1000001], fa[1000001], siz[1000001], root[1000001], a[1000001], mp[1000001], ans[1000001];struct edge &#123; int next, to;&#125;e[1000001];inl void adde(int x, int y) &#123; e[++tot] = edge&#123; head[x],y &#125;, head[x] = tot; e[++tot] = edge&#123; head[y],x &#125;, head[y] = tot;&#125;inl void dfs1(int x) &#123; dep[x] = dep[fa[x]] + 1, siz[x] = 1; for (re i = head[x]; i; i = e[i].next) &#123; if (fa[x] != e[i].to) &#123; fa[e[i].to] = x; dfs1(e[i].to); siz[x] += siz[e[i].to]; siz[e[i].to] &gt; siz[h[x]] ? h[x] = e[i].to : 0; &#125; &#125;&#125;inl void dfs2(int x) &#123; if (h[x]) &#123; top[h[x]] = top[x]; dfs2(h[x]); &#125; for (re i = head[x]; i; i = e[i].next) &#123; if (!top[e[i].to]) &#123; top[e[i].to] = e[i].to; dfs2(e[i].to); &#125; &#125;&#125;inl int lca(int x, int y) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]])swap(x, y); x = fa[top[x]]; &#125; return dep[x] &lt; dep[y] ? x : y;&#125;inl void solve(int x) &#123; for (re i = head[x]; i; i = e[i].next) &#123; if (e[i].to != fa[x]) &#123; solve(e[i].to); root[x] = merge(root[x], root[e[i].to], 1, s); &#125; &#125; ans[x] = t[root[x]].w ? mp[t[root[x]].c] : 0;&#125;struct quiz &#123; int x, y, z;&#125;q[1000001];signed main() &#123; re n = read&lt;int&gt;(), m = read&lt;int&gt;(), x, y, z, f; top[1] = 1; for (re i = 1; i &lt; n; i++)adde(read&lt;int&gt;(), read&lt;int&gt;()); for (re i = 1; i &lt;= m; i++) x = read&lt;int&gt;(), y = read&lt;int&gt;(), a[i] = z = read&lt;int&gt;(), q[i] = quiz&#123; x,y,z &#125;; sort(a + 1, a + 1 + m); s = unique(a + 1, a + 1 + m) - a - 1; dfs1(1), dfs2(1); for (re i = 1, k; i &lt;= m; i++) k = q[i].z, mp[q[i].z = lower_bound(a + 1, a + 1 + s, q[i].z) - a] = k; for (re i = 1; i &lt;= m; i++) &#123; x = q[i].x, y = q[i].y, z = q[i].z, f = lca(x, y); add(root[x], 1, s, z, 1), add(root[y], 1, s, z, 1), add(root[f], 1, s, z, -1); if (fa[f])add(root[fa[f]], 1, s, z, -1); &#125; solve(1); for (re i = 1; i &lt;= n; i++)writeln(ans[i]);&#125;","categories":[],"tags":[{"name":"线段树合并","slug":"线段树合并","permalink":"http://Geiz-Revive.github.io/tags/线段树合并/"}]}]}